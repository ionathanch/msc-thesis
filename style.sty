\ProvidesPackage{style}

% required packages
\RequirePackage{xspace}
\RequirePackage{xcolor}
\RequirePackage{suffix}
\RequirePackage{mathtools}
\RequirePackage{stmaryrd}
\RequirePackage{mathpartir}

% save default lengths
\newlength{\fboxsepdefault}
\setlength{\fboxsepdefault}{\fboxsep}

% \newcmd*{\cmd}[n]{expression} defines the suffixed command \cmd*
% similarly for \newcmd<
\WithSuffix\newcommand\newcmd*[3]{\WithSuffix\newcommand#1*#2{#3}}
\WithSuffix\newcommand\newcmd<[3]{\WithSuffix\newcommand#1<#2{#3}}

% rule labels:
% \rlabel{name}{label} creates given label and prints name
% \rref{label} prints "Rule <name>"
% \rref{label, label} prints "Rules <name> and <name>"
% \rref{label, ..., label} prints "Rules <name>, ..., and <name>"
% NOTE: \rule and \@rule seem to conflict with footnotes, somehow??
\newcounter{nrules}
\newcommand{\rlabel}[2]{%
  \edef\@currentlabelname{#1}%
  \phantomsection\label{#2}#1%
}
\newcmd*{\rlabel}[1]{\rlabel{#1}{#1}}
\newcommand{\rref}[1]{%
  \setcounter{nrules}{0}%
  \edef\r@les{\zap@space #1 \@empty}%
  \@for\r@le:={#1}\do{\addtocounter{nrules}{1}}%
  \ifcase \value{nrules}
  \or Rule~\textsc{\nameref{#1}}%
  \or Rules\@for\r@le:={\r@les}\do{
    \ifcase \value{nrules}
    \or and \textsc{\nameref{\r@le}}%
    \else \textsc{\nameref{\r@le}}%
    \fi
    \addtocounter{nrules}{-1}%
  }%
  \else Rules\@for\r@le:={\r@les}\do{
    \ifcase \value{nrules}
    \or and \textsc{\nameref{\r@le}}%
    \else \textsc{\nameref{\r@le}},%
    \fi
    \addtocounter{nrules}{-1}%
  }%
  \fi
}

% colours for:
% - metafunctions (pale magenta)
% - keywords (golden yellow)
% - constants (soft blue)
% - constructions (turquoise)
% - target language (dark orange)
% by Okabe and Ito (https://jfly.uni-koeln.de/color/#pallet)
\definecolor{metacolour}{HTML}{CC79A7}
\definecolor{kwcolour}{HTML}{E69F00}
\definecolor{constcolour}{HTML}{0072B2}
\definecolor{constrcolour}{HTML}{009E73}
\definecolor{targetcolour}{HTML}{D55E00}
\definecolor{newcolour}{gray}{0.85}

% various theorem environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}

% foreign phrases
\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\ie}{\emph{i.e.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}
\newcommand{\ala}{\emph{\`a la}\xspace}
\newcommand{\TODO}{\meta{\texttt{TODO}}\xspace}

% language names
\newcommand{\lang}{\texorpdfstring{$\widehat{\mathrm{TT}}$}{TT}\xspace}
\newcommand{\GCC}{CC$^\omega$\xspace}
\newcommand{\Fstar}{F$\star$\xspace}
\newcommand{\lambdahat}{$\lambda\widehat{~}$\xspace}
\newcommand{\Fhat}{F$\widehat{~}$\xspace}
\newcommand{\Fhatomega}{F$\widehat{_\omega}$\xspace}
\newcommand{\Fhattimes}{F$\widehat{_{\times}}$\xspace}
\newcommand{\Fcopomega}{F$^{\textrm{cop}}_{\omega}$\xspace}
\newcommand{\CICE}{CIC$_E$\xspace}
\newcommand{\CIChat}{CIC$\widehat{~}$\xspace}
\newcommand{\CIChatminus}{CIC$\widehat{_-}$\xspace}
\newcommand{\CChatomega}{CC$\widehat{\omega}$\xspace}
\newcommand{\CIChatstar}{CIC$\widehat{\ast}$\xspace}
\newcommand{\CIChatl}{CIC$\widehat{_\ell}$}

% styling
\newcommand{\meta}[1]{\textcolor{metacolour}{#1}}
\newcommand{\kw}[1]{\mathsf{\textcolor{kwcolour}{#1}}}
\newcommand{\const}[1]{\mathsf{\textcolor{constcolour}{#1}}}
\newcommand{\constr}[1]{\mathsf{\textcolor{constrcolour}{#1}}}
\newcommand{\target}[1]{\begingroup%
  \definecolor{metacolour}{named}{targetcolour}
  \definecolor{kwcolour}{named}{targetcolour}
  \definecolor{constcolour}{named}{targetcolour}
  \definecolor{constrcolour}{named}{targetcolour}
  \renewcommand{\mathsf}{\mathtt}
  \mathtt{{\textcolor{targetcolour}{#1}}}
\endgroup}
\newcommand{\new}[1]{%
  \setlength{\fboxsep}{3pt}%
  \colorbox{newcolour}{\rule{0em}{0.5\baselineskip}#1}%
  \setlength{\fboxsep}{\fboxsepdefault}%
}

% delimiters
\DeclarePairedDelimiter{\sqbr}{[}{]}
\DeclarePairedDelimiter{\set}{\{}{\}}
\DeclarePairedDelimiter{\ang}{\langle}{\rangle}

% metafunctions
\newcommand{\mt}{\,\meta{\cdot}\,}
\newcommand{\seq}{\,\meta{\ldots}\,}
\newcommand{\any}{\meta{\texttt{\_}}}
\newcommand{\subst}[3]{#1\mathopen{\meta{[}}#2 \mathrel{\meta{\mapsto}} #3\mathclose{\meta{]}}}
\newcommand{\card}[1]{\mathopen{\meta{\lvert}} #1 \mathclose{\meta{\rvert}}}
\newcommand{\compile}[1]{\mathopen{\meta{\llbracket}} #1 \mathclose{\meta{\rrbracket}}}
\newcommand{\metafun}[2]{\meta{\texttt{#1(}}#2\meta{\texttt{)}}}
\newcmd*{\metafun}[1]{\meta{\texttt{#1}}}
\newcommand{\maximum}[1]{\metafun{max}{#1}}
\newcommand{\minimum}[1]{\metafun{min}{#1}}
\newcommand{\rules}[2]{\metafun{rule}{#1, #2}}
\newcommand{\axioms}[1]{\metafun{axiom}{#1}}
\newcommand{\fresh}[1]{\metafun{fresh}{#1}}
\newcommand{\FV}[1]{\metafun{FV}{#1}}

% source binders
\newcommand{\annot}[2]{#1 \mathrel{:} #2}
\newcommand{\define}[2]{#1 \mathrel{\coloneqq} #2}
\newcommand{\bound}[2]{#1 \mathrel{<} #2}

% source language
\newcommand{\@et}{\:}
\newcommand{\Type}[1]{\const{Type}_{#1}}
\newcommand{\Prop}{\const{Prop}}
\newcommand{\sss}[1]{\widehat{#1}}
\newcommand{\app}[1]{#1\@ifnextchar\bgroup{\@et\app}{\xspace}}
\newcommand{\@pp}[1]{\sqbr{#1}\@ifnextchar\bgroup{\@et\@pp}{\xspace}}
\newcommand{\App}[1]{#1\@ifnextchar\bgroup{\@et\@pp}{\xspace}}
\newcommand{\fun}[3]{\lambda \annot{#1}{#2} \mathpunct{.} #3}
\newcmd*{\fun}[2]{\lambda #1 \mathpunct{.} #2}
\newcommand{\Fun}[2]{\Lambda #1 \mathpunct{.} #2}
\newcmd<{\Fun}[3]{\Lambda \bound{#1}{#2} \mathpunct{.} #3}
\newcommand{\funtype}[3]{\Pi \annot{#1}{#2} \mathpunct{.} #3}
\newcommand{\Funtype}[2]{\forall #1 \mathpunct{.} #2}
\newcmd<{\Funtype}[3]{\forall \bound{#1}{#2} \mathpunct{.} #3}
\newcommand{\arr}[3]{\mathopen{(} \annot{#1}{#2} \mathclose{)} \mathrel{\rightarrow} \phantom{} #3}
\newcmd*{\arr}[1]{#1\@ifnextchar\bgroup{\mathrel{\rightarrow}\arr*}{\xspace}}
\newcommand{\letin}[4]{\kw{let} \@et #1 \mathrel{\coloneqq} \phantom{} #3 \@et \kw{in} \@et #4}
\newcommand{\Let}[3]{\kw{let} \@et \annot{#1}{#2} \mathrel{\coloneqq} \phantom{} #3}
\newcommand{\Pairtype}[2]{\exists #1 \mathpunct{.} #2}
\newcommand{\Pair}[2]{\ang{#1 \mathpunct{,} #2}}
\newcommand{\unpair}[6]{\kw{let} \@et \Pair{#1}{#2}_{\Pairtype{#3}{#4}} \mathrel{\coloneqq} #5 \@et \kw{in} \@et #6}
\newcmd*{\unpair}[4]{\kw{let} \@et \Pair{#1}{#2} \mathrel{\coloneqq} #3 \@et \kw{in} \@et #4}
\newcommand{\eq}[3]{#1 \stackrel{#2}{=\joinrel=} #3}
\newcommand{\refl}[1]{\constr{refl}_{#1}}
\newcommand{\J}[3]{\constr{J}_{#1} \@et #2 \@et #3}
\newcmd*{\J}[0]{\constr{J}}

% source inductives
\newcmd*{\data}[1]{\kw{data} \@et #1 \@et \kw{where}}
\newcommand{\N}[1]{\App{\const{\mathbb{N}}}{#1}}
\newcmd*{\N}[0]{\const{\mathbb{N}}}
\newcommand{\W}[4]{\App{\const{\mathbb{W}} \annot{#1}{#2} \mathpunct{.} #3}{#4}}
\newcmd*{\W}[0]{\const{\mathbb{W}}}
\newcommand{\zero}[2]{\App{\constr{zero}_{\N{#1}}}{#2}}
\newcmd*{\zero}[0]{\constr{zero}}
\renewcommand{\succ}[3]{\app{\App{\constr{succ}_{\N{#1}}}{#2}}{#3}}
\newcmd*{\succ}[0]{\constr{succ}}
\renewcommand{\sup}[7]{\app{\App{\constr{sup}_{\W{#1}{#2}{#3}{#4}}}{#5}}{#6}{#7}}
\newcmd*{\sup}[0]{\constr{sup}}
\newcommand{\List}[2]{\App{\app{\const{List}}{#1}}{#2}}
\newcmd*{\List}[0]{\const{List}}
\newcommand{\nil}[3]{\App{\constr{nil}_{\List{#1}{#2}}}{#3}}
\newcmd*{\nil}[0]{\constr{nil}}
\newcommand{\cons}[5]{\app{\App{\constr{nil}_{\List{#1}{#2}}}{#3}}{#4}{#5}}
\newcmd*{\cons}[0]{\constr{cons}}
\newcommand{\match}[3]{\kw{case} \@et #1 \@et \kw{return} \@et #2 \@et \kw{of} \@et \phantom{} #3}
\newcmd*{\match}[2]{\kw{case} \@et #1 \@et \kw{of} \@et \phantom{} #2}
\newcommand{\fix}[5]{\kw{fix}_{#1} \@et #2 \@et \sqbr{#3} \mathrel{:} #4 \mathrel{\coloneqq} \phantom{} #5}

% source judgements
\newcommand{\wf}[2]{#1 \mathrel{\vdash} #2}
\renewcommand{\check}[3]{#1 \mathrel{\vdash} #2 \mathrel{:} #3}
\renewcommand{\infer}[3]{#1 \mathrel{\vdash} #2 \mathrel{:} #3}
\newcommand{\type}[3]{#1 \mathrel{\vdash} \annot{#2}{#3}}
\newcommand{\defeq}[4]{#1 \mathrel{\vdash} \annot{#2 \mathrel{\equiv} #3}{#4}}
\newcommand{\subsize}[3]{#1 \mathrel{\vdash} #2 \mathrel{\leqslant} #3}
\newcommand{\subtype}[3]{#1 \mathrel{\vdash} #2 \mathrel{\preccurlyeq} #3}
\newcommand{\acum}[2]{#1 \mathrel{\sqsubseteq} #2}
\newcommand{\red}[4][]{#2 \mathrel{\vdash} #3 \mathrel{\rhd}_{#1} #4}
\newcmd*{\red}[3]{#1 \mathrel{\vdash} #2 \mathrel{\rhd^*} #3}

% example names
\newcommand{\id}{\mathit{id}}
\newcommand{\Id}{\mathit{Id}}