\chapter{Overview} \label{ch:overview}

% TODO: make sure to name \lang in the intro
\epigraphic[0.51]{14?! Ridiculous! We need to develop one universal standard that covers everyone's use cases.}
{Randall Munroe, \href{https://xkcd.com/927/}{\textsc{xkcd} \texttt{\#927}}}

What need is there for yet another sized type system?
Since \citet{hughes}, there has been a little over two decades' worth of past work on sized types.
\citet{flationary} notes that it has been the topic of at least five dissertations.
This chapter alone names a dozen different type systems with sized types.
There have been many advancements along the way,
but none quite satisfactory to close the matter,
especially when it comes to dependent types.

\lang, the next three chapters, and this thesis as a whole does not aim to resolve
all of the remaining problems of sized types left open by these past works.
Instead, the purpose is threefold:

\begin{itemize}
  \item To fill an existing gap in sized dependent type theories.
    Two modern sized type features are higher-rank and bounded size quantification,
    and there exist a few dependent type theories with one or the other,
    but not both, to my knowledge.
    On the other hand, they are currently in Agda's implementation of sized types.
    By proving the consistency of \lang, a novel type theory with these two features,
    I bring the theoretical state-of-the-art closer to practice.
  \item To demonstrate the viability of using a syntactic model to prove consistency
    of a sized type theory.
    Doing so from scratch through a set-theoretic model is notoriously difficult,
    and often requires sacrifices to and constraints on the type theory;
    see Sacchini's dissertation~\citep{CIC-hat-minus} or \CIChatstar~\citep{CIC-hat-star},
    for instance.
    Instead, a syntactic model relies on the consistency of the language in which I'm modelling,
    and requires no additional deep mathematical knowledge.
  \clearpage % NOTE: cross-page bullet points are gross, but this may change
  \item To reopen the discussion on sized dependent types.
    Since the discovery of the inconsistency of Agda's sized types%
    \footnote{\label{foot:agda-inconsistent} See issue \#2820 of the Agda repo,
    \textit{Equality is incompatible with sized types},
    URL \url{https://github.com/agda/agda/issues/2820}.},
    progress appears to have stagnated a little.
    In later chapters, I examine these difficulties as they might apply to \lang
    and its interpretation in the syntactic model.
\end{itemize}

I begin in this chapter by describing and justifying the design of
the dependent types and the sized types of \lang,
explaining how a syntactic model is used to prove its consistency,
and briefly outlining the structure of the proof.

\section{Dependent Types}

As a simple but expressive foundation for dependent types,
I start with the generalized Calculus of Constructions (\GCC)\index{Calculus of Constructions!generalized \textasciitilde},
originally proposed by \citet{GCC-Coquand},
proven strongly normalizing by \citet{GCC-Luo},
and extended to include definitions by \citet{universes}.
It has the following features:

\begin{itemize}
  \item \textbf{Dependent function types}, as is standard in the Calculus of Constructions (CC)~\citep{CoC}\index{Calculus of Constructions};
  \item \textbf{Definitions}, \ie locally-named expressions;
  \item \textbf{Universes \ala Russell}\index{universes \ala Russell}, where the types of types are themselves terms
    (as opposed to universes \ala Tarski\index{universes \ala Tarski}, where their \emph{encodings} are terms);
  \item An \textbf{impredicative universe}\index{impredicativity} $\Prop$ such that function types into types in $\Prop$
    are themselves in $\Prop$;
  \item A \textbf{cumulative hierarchy of universes}\index{cumulativity} such that $\Type{i}: \Type{i+1}$,
    any term in $\Type{i}$ is also in $\Type{j}$ given \emph{universe levels}\index{universe level} $i \leq j$,
    and there is a subtyping relation\index{subtyping} on types induced by this inclusion; and
  \item \textbf{Untyped conversion}\index{conversion} stating when two terms are judgementally equal to one another.
\end{itemize}

These features cover many modern proof assistants.
To name a few, in terms of universes,
Coq and Arend have all of the above;
Lean lacks cumulativity; and
Agda and \Fstar lack cumulativity and impredicative universe.
On the other hand, these proof assistants all have some form of
\emph{universe level polymorphism},
but this is much more complex and largely orthogonal to sized types
and the syntactic model.

Perhaps the most contentious design decision so far is the use of untyped conversion,
as can be found in Coq, over typed conversion or \emph{equivalence}\index{equivalence}%
\marginnote{\emph{Conversion} refers to untyped judgemental equality
while \emph{equivalence} refers to typed judgemental equality hereafter.},
as can be found in Agda.
Certain proponents%
\footnote{This would be a fun place to link to someone's tweets.}
will argue that equivalence is ``more correct'',
since it never deals with ill-typed terms,
but this means that the equivalence judgement depends on the typing judgement.
Meanwhile, since types can depend on terms,
typing itself depends on equivalence to check whether one type can be used in place of another.
As we'll see in \cref{sec:syntactic-model}, these mutually-defined judgements would greatly complicate the proofs,
so I settle for conversion instead.

On top of \GCC, I add two inductive definitions featured in Martin--L\"of type theory (MLTT)~\citep{mltt}\index{Martin--L\"of type theory}:
the \emph{Peano naturals}\index{naturals} and \emph{well-founded trees}\index{well founded!\textasciitilde trees}, augmented with sizes.
As the simplest nontrivial inductive,
the naturals make it easy to demonstrate intuitive uses of sized inductives.
On the other hand, well-founded trees are an example of \emph{generalized} inductives,
with recursive arguments that are functions that return well-founded trees,
and can in fact encode all (nonmutual, nonnested) inductives---%
although not so much their proper induction principles~\citep{W-types}.
I don't add inductive types in general in their place
because the syntactic baggage that comes with handling the generalization
obscures the intuition behind sized inductive types and the syntactic model,
while it's easy to see how one \emph{could} go from the naturals and from well-founded trees
to inductive types in general.

\iffalse
Finally, I add a standard \emph{homogeneous propositional equality type}\index{propositional equality},
which isn't particularly difficult to deal with
and will allow for some more interesting examples.
\fi

\section{Sized Types}\label{sec:sized-types}

Sized types are introduced with explicit size quantification $\Funtype{\alpha}{\tau}$,
size abstraction $\Fun{\alpha}{e}$, and size application $\App{e}{s}$.
Sizes themselves consist of size variables as well as a \emph{base size}
and a \emph{size successor operator}.
This is the standard for size expressions in sized type systems.
% TODO: forward ref to related work
Some such as \Fhattimes~\citep{F-hat-times} and \CIChatl~\citep{CIC-hat-l}
add addition of size variables and multiplication by a natural, respectively,
increasing expressivity at the expense of complexity.
To keep things simple, I don't include these features and stick to successor sizes.
Note that size expressions are \emph{not} terms,
and their quantifications, abstractions, and applications
are syntactically distinct from those of terms,
similar to how, in nondependent polymorphic type systems,
types are distinct from terms.

Having explicit sizes differs from some sized type systems such as
\lambdahat~\citep{lambda-hat, lambda-hat-diss},
\Fhat~\citep{F-hat}, \CIChat~\citep{CIC-hat},
\CIChatminus~\citep{CIC-hat-minus-nat, CIC-hat-minus},
\CChatomega~\citep{CC-hat-omega}, and \CIChatstar~\citep{CIC-hat-star} where,
extending the type polymorphism analogy,
there is only implicit \emph{rank-1} or
\emph{prenex}\index{polymorphism!prenex/rank-1 \textasciitilde} size quantification:
size quantifications never appear inside of a type,
and in fact all size abstractions and applications are fully inferred.
Explicit sizes, in contrast, let us express
\emph{higher-rank}\index{polymorphism!higher-rank \textasciitilde} size quantification,
which is also found in \Fhatomega~\citep{Abel-diss},
\Fcopomega~\citep{F-omega-cop},
and in a MLTT-style sized dependent type theory~\cite{NbE}.
Higher-rank sizes allow for more expressiveness:
for instance, supposing we have cons lists parametrized over some sized type $\tau$,
one could write a size-preserving mapping function over a list
that leaves the sizes untouched.
The type of such a function might be
$$\Funtype{\alpha}{\arr*{(\Funtype{\beta}{\arr*{\App{\tau}{\beta}}{\App{\tau}{\beta}}})}{\app{\List*}{(\App{\tau}{\alpha})}}{\app{\List*}{(\App{\tau}{\alpha})}}}.$$

Along with higher-rank sizes, I also include \emph{bounded} size quantification $\Funtype<{\alpha}{s}{\tau}$
and abstraction $\Fun<{\alpha}{s}{e}$.
An order on sizes is induced by these bound instantiations and the successor operator;
this order has nothing to do with subtyping,
and in particular we do \emph{not} have subtyping relations between
$\N{\alpha}$ and $\N{\sss{\alpha}}$, for instance.
% TODO: forward ref to where we define the cast between the two
Fixpoint expressions recur on smaller sizes according to the order,
summarized by the below typing rule.
%
\begin{mathpar}
\inferrule[]{
  \check{\Phi, \alpha; \Gamma, f: \Funtype<{\beta}{\alpha}{\subst{\tau}{\alpha}{\beta}}}{e}{\tau}
}{
  \infer{\Phi; \Gamma}{\fix{f}{\alpha}{\tau}{e}}{\Funtype{\alpha}{\tau}}
}
\end{mathpar}

Bounded sizes were originally introduced for MiniAgda~\citep{MiniAgda, flationary}
to avoid complex \emph{semi-continuity}\index{semi-continuity} or approximative \emph{polarity}\index{polarity}
requirements on fixpoints' types in the presence of an \emph{infinite size}\index{infinite size}
that is strictly larger than all sizes.
Although I don't include an infinite size,
this style of recursion is more elegant because it corresponds neatly to well-founded induction on sizes.

In summary, the sized type features I include are:

\begin{itemize}[noitemsep]
  \item \textbf{Explicit size} quantification $\Funtype{\alpha}{\tau}$,
    abstraction $\Fun{\alpha}{e}$, and
    application $\App{e}{s}$;
  \item A \textbf{simple size grammar} with size variables $\alpha$, a base size $\circ$, and successors $\sss{s}$;
  \item \textbf{Higher-rank sizes}, \eg $\arr*{(\Funtype{\alpha}{\tau})}{\sigma}$;
  \item \textbf{Bounded size} quantification $\Funtype<{\alpha}{s}{\tau}$ and
  abstraction $\Fun<{\alpha}{s}{e}$.
\end{itemize}

Notably, these are all features found in Agda's implementation of sized types.
The only missing feature is the infinite size,
since its properties and its use are known to be inconsistent in Agda%
\textsuperscript{\labelcref{foot:agda-inconsistent}}.
% TODO: forward ref to discussion on the infinite size
% TODO: mention ⊔ or add it??

\section{Syntactic Model}\label{sec:syntactic-model}

To show that \lang is consistent and therefore a suitable type theory for proofs,
I define for it a \emph{syntactic model}\index{syntactic model}~\citep{syntactic-models}.
This involves defining a translation from \lang into some target type theory
that is known to be consistent---in this case,
the \emph{extensional Calculus of Inductive Constructions}\index{Calculus of Inductive Constructions}
(\CICE)~\citep{CCE, CICE}.
It, too, has a cumulative hierarchy of universes \ala Russell and an impredicative universe,
augmented with inductive types and \emph{equality reflection}\index{equality reflection},
where a definitional equality between terms can be derived from a propositional one between them.
The most notable difference from \lang, aside from these features and sized types,
is that \CICE must use the typed equivalence rather than the untyped conversion
to accomodate equality reflection.
% TODO: forward ref to discussion on inconsistency of untyped conversion + equality reflection

This translation from \lang to \CICE must be \emph{type preserving}\index{type preservation}:
if some term $e$ is well typed under some environments $\Phi; \Gamma$ with some type $\tau$,
then the translated term $\compile{e}$ must also be well typed
under the translated environment $\compile{\Phi}\compile{\Gamma}$
with the translated type $\compile{\tau}$.
With the consistency of \CICE and a type-preserving translation to it,
we prove the consistency of \lang.
\marginnote{Terms, environments, etc. typeset in
\textcolor{targetcolour}{\texttt{vermilion teletype}}
belong to the target language \CICE.}

\begin{fact}[Consistency of \CICE]\label{fact:consistency-cice}
There exists no term $\eT$ such that
$\type{\mt}{\eT}{\funtypeT{\PT}{\PropT}{\PT}}$.
\end{fact}

\begin{theorem}[Consistency of \lang]
Suppose $\compile{\bot} = \funtypeT{\PT}{\PropT}{\PT}$.
Then there exists no term $e$ such that \mbox{$\type{\mt \mathbin{;} \mt}{e}{\bot}$}.
\end{theorem}
\begin{proof}
Suppose that there were such a term $e$.
By the type-preserving translation, we would have that
$\type{\mt}{\compile{e}}{\funtypeT{\PT}{\PropT}{\PT}}$ holds.
However, this contradicts \cref{fact:consistency-cice},
so there must not be such a term.
\end{proof}

What remains, then, is to define $\bot$ and an appropriate translation from \lang to \CICE
such that $\compile{\bot} = \funtypeT{\PT}{\PropT}{\PT}$,
and to show that this translation is type preserving.
I define my translation by induction on the typing derivations of \lang
rather than merely over its syntax,
ensuring that only well-typed terms have a translation.
% TODO: forward ref here?

Type preservation of the translation is proven by induction on not only the typing derivations,
but also the derivations of the judgements on which the typing rules depend.
In particular, typing depends on subtyping\index{subtyping}, which in turn depends
on \emph{$\alpha$-cumulativity}\index{$\alpha$-cumulativity}~\citep{MetaCoq}
and on the reflexive, transitive, congruent closure of \emph{reduction}\index{reduction}.
Finally, this closure of reduction depends on the reduction rules,
most of which are defined by substitution.
Below are the relevant rules showing these dependencies and an example reduction rule.
%
\begin{mathpar}
\inferrule[]{
  \dots \\\\
  \infer{\Phi; \Gamma}{e}{\sigma} \\\\
  \subtype{\Phi; \Gamma}{\sigma}{\tau}
}{
  \check{\Phi; \Gamma}{e}{\tau}
}

\inferrule[]{
  \acum{\sigma_1}{\sigma_2} \\\\
  \red*{\Phi; \Gamma}{\tau_1}{\sigma_1} \\\\
  \red*{\Phi; \Gamma}{\tau_2}{\sigma_2}
}{
  \subtype{\Phi; \Gamma}{\tau_1}{\tau_2}
}

\inferrule[]{
  \red{\Phi; \Gamma}{e_1}{e_2} \\\\
  \red*{\Phi; \Gamma}{e_2}{e_3}
}{
  \red*{\Phi; \Gamma}{e_1}{e_3}
}

\inferrule[]{~}{
  \red{\Phi; \Gamma}{\app{(\fun{x}{\tau}{e})}{e'}}{\subst{e}{x}{e'}}
}
\end{mathpar}

We therefore need some lemmas showing that the translation respects
substitution, reduction, the closure of reduction, $\alpha$-cumulativity, and subtyping
in order to prove type preservation.
In short, substitution satisfies a \emph{compositionality}\index{compositionality} principle,
reduction of terms are equivalent by the \CICE equivalence judgement
$\defeq{\GammaT}{\eT_1}{\eT_2}{\tauT}$,
and $\alpha$-cumulative terms and subtypes are correspondingly \CICE subtypes.
I summarize them here, omitting some hypotheses and sublemmas,
to outline the proof architecture,
which roughly follows the structure of type-preserving compilation by~\citet{wjb}.

\begin{lemma}[Compositionality]\label{lem:compositionality}\hfill
\begin{enumerate}[noitemsep]
  \item $\compile{\subst{e}{x}{e'}} = \subst{\compile{e}}{x}{\compile{e'}}$.
  \item $\compile{\subst{e}{\alpha}{s}} = \subst{\compile{e}}{\alpha}{\compile{s}}$
\end{enumerate}
\end{lemma}

\begin{proof}
By induction on the derivation of $\type{\Phi; \Gamma}{e}{\tau}$.
\end{proof}

\begin{lemma}[Preservation of Reduction]\label{lem:pres-red}
If $\red{\Phi; \Gamma}{e}{e'}$ and
$\type{\compile{\Phi}\compile{\Gamma}}{\compile{e}}{\compile{\tau}}$
then $\defeq{\compile{\Phi}\compile{\Gamma}}{\compile{e}}{\compile{e'}}{\compile{\tau}}$.
\end{lemma}

\begin{proof}
By cases on the derivation of $\red{\Phi; \Gamma}{e}{e'}$
and inversion on the derivation of $\type{\compile{\Phi}\compile{\Gamma}}{\compile{e}}{\compile{\tau}}$,
using \cref{lem:compositionality}
and an application of equality reflection in the case for reduction of fixpoints.
\end{proof}

\begin{lemma}[Preservation of $\alpha$-Cumulativity]\label{lem:pres-cumul}
If $\acum{\tau_1}{\tau_2}$ and
$\type{\compile{\Phi}\compile{\Gamma}}{\compile{\tau_i}}{\UT_i}$
then $\subtype{\compile{\Phi}\compile{\Gamma}}{\compile{\tau_1}}{\compile{\tau_2}}$.
\end{lemma}

\begin{proof}
By induction on the derivation of $\acum{\tau_1}{\tau_2}$,
using inversion on the derivations of $\type{\Phi; \Gamma}{\tau_i}{U_i}$ and
$\type{\compile{\Phi}\compile{\Gamma}}{\compile{\tau_i}}{\UT_i}$.
\end{proof}

The final three lemmas and theorem are proven mutually;
I state them separately for clarity.

\begin{lemma}[Preservation of Reflexive, Transitive, Congruent Closure of Reduction]\label{lem:pres-red*}
If $\red*{\Phi; \Gamma}{e}{e'}$ and
$\type{\compile{\Phi}\compile{\Gamma}}{\compile{e}}{\compile{\tau}}$
then $\defeq{\compile{\Phi}\compile{\Gamma}}{\compile{e}}{\compile{e'}}{\compile{\tau}}$.
\end{lemma}

\begin{proof}
By lexicographical induction on the derivations of $\red*{\Phi; \Gamma}{e}{e'}$
and of $\type{\Phi; \Gamma}{e}{\tau}$,
using \cref{lem:pres-red}, \cref{lem:pres-subtyping}, and \cref{lem:pres-typing}.
\end{proof}

\begin{lemma}[Preservation of Subtyping]\label{lem:pres-subtyping}
If $\subtype{\Phi; \Gamma}{\tau_1}{\tau_2}$
then $\subtype{\compile{\Phi}\compile{\Gamma}}{\compile{\tau_1}}{\tau_2}$.
\end{lemma}

\begin{proof}
By cases on the derivation of $\subtype{\Phi; \Gamma}{\tau_1}{\tau_2}$,
using \cref{lem:pres-cumul}, \cref{lem:pres-red*}, and subject reduction of \lang.
\end{proof}

\begin{theorem}[Type Preservation]\label{lem:pres-typing}\hfill
\begin{enumerate}[noitemsep]
  \item If $\wf{\Phi}{\Gamma}$ then $\wf{}{\compile{\Phi}\compile{\Gamma}}$.
  \item If $\type{\Phi; \Gamma}{e}{\tau}$ then $\type{\compile{\Phi}\compile{\Gamma}}{\compile{e}}{\compile{\tau}}$.
\end{enumerate}
\end{theorem}

\begin{proof}
By mutual induction on the derivations of $\wf{\Phi}{\Gamma}$ and $\type{\Phi; \Gamma}{e}{\tau}$,
using \cref{lem:pres-subtyping}.
\end{proof}

The most important properties required of \lang are subject reduction,
used in \cref{lem:pres-subtyping},
and confluence, which is used to show that subtyping is transitive,
which in turn is used to prove the inversion principles for the typing judgement.

This proof structure is possible by virtue of the non-mutuality of the judgements of \lang
due to the use of untyped conversion (and hence untyped reduction).
If it were instead typed, then it would mutually depend on typing and subtyping as well,
and the above lemmas would circularly depend on one another~\citep{wjb}. \\

\noindent In the next chapter, I describe the syntax and judgements of \lang in detail,
provide example programs in \lang that make use of sized types,
and prove various necessary metatheoretical properties including subject reduction and confluence.
Next, in \TODO I describe \CICE and define the translation from \lang to \CICE.
Following that, I elaborate on the proof of type preservation and its associated lemmas.
% TODO: forward ref to sections mentioned