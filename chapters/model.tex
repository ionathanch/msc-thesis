\chapter{Syntactic Model of \lang} \label{ch:model}

\input{figures/cic.tex}
\input{figures/definitions.tex}
\input{figures/translation.tex}

The type theory in which \lang is modelled is
\CICE\index{Calculus of Inductive Constructions!Extensional \textasciitilde},
as briefly described in \cref{ch:introduction}.
The key idea is that sizes in \lang can themselves be represented as a inductive type in \CICE,
and naturals and well-founded trees are then inductives with an additional size parameter.
Sizes are represented as a (generalization of) the Brouwer notation for ordinals in type theory,
and their order as an inductive type indexed by sizes.
The order is \emph{well-founded}:
there is no infinite sequence of ever-smaller sizes,
and there is always a ``smallest'' size (or many of them).
This property allows for \emph{well-founded induction}\index{well-founded induction},
where to prove some property on sizes, one supposes that it holds for all strictly smaller sizes.

Every fixpoint expression in \lang is modelled as an instance of well-founded induction in \CICE.
To prove well-foundedness and in turn the induction principle,
I show that sizes satisfy an \emph{accessiblity predicate}\index{accessibility predicate}~\citep{accessibility}.
For the type preservation proof to go through,
\emph{definitional proof irrelevance}\index{proof irrelevance}
of accessibility predicates is required---that is,
every proof of accessibility is definitionally equal to one another.
This holds in extensional type theory via equality reflection\index{equality reflection}
but not in intensional type theory,
which is why an extensional CIC is used.

The first half of this chapter provides the syntax and judgements of \CICE.
In addition to the notation used in \cref{ch:sized-dep-types},
given variables $\vec{\xT} = \xT_1 \seq \xT_n$,
terms $\vec{\eT} = \eT_1 \seq \eT_n$,
and types $\vec{\tauT} = \tauT_1 \seq \tauT_n$,
\new{$\annotT{\vec{\xT}}{\vec{\tauT}}$} denotes the assumption environment
$\annotT*{\xT_1}{\tauT_1}, \seq, \annotT*{\xT_n}{\tauT_n}$,
\new{$\subst{\eT}{\vec{\xT}}{\vec{\eT}}$} denotes the simultaneous substitution
$\subst{\eT}{\xT_1, \seq, \xT_n}{\eT_1, \seq, \eT_n}$, 
\new{$\funT{\vec{\xT}}{\vec{\tauT}}{\eT}$} denotes the $n$-ary function
$\funT{\xT_1}{\tauT_1}{\seq \funT{\xT_n}{\tauT_n}{\eT}}$, and
\new{$\type{\GammaT}{\vec{\eT}}{\vec{\tauT}}$} denotes the $n$ typing judgements
$(\type{\GammaT}{\eT_1}{\tauT_1})$, \seq, $(\type{\GammaT, \annotT{\eT_1}{\tauT_1}, \seq, \annotT{\eT_{n-1}}{\tauT_{n-1}}}{\eT_n}{\tauT_n})$.

The second half then describes the translation from \lang to \CICE,
which is a metafunction from typing derivations of \lang to terms of \CICE.
Therefore, the translation is only defined for well-typed \lang terms,
but the type preservation theorem only applies to well-typed terms anyway.

\section{Target Type Theory} \label{sec:target}

\FigSyntaxCIC{fig:syntax-cic}
The syntax of \CICE
is given in \cref{fig:syntax-cic};
differences from \lang include a 1-based index for the recursive argument of fixpoint expressions,
$\tg{case}$ expression motives abstracted over the target's inductive type indices,
and a homogeneous propositional equality\index{propositional equality} type with the reflexivity constructor and $\JT*$ eliminator.
New inductive types are defined using data definitions $\DT$,
whose syntax resembles the informal presentation used in \cref{ch:sized-dep-types}.
Metavariable usage convention is roughly the same as for \lang,
with the addition of $\pT$ for inductive type parameters or proofs of equality
and $\aT$ for inductive type indices.

The well-formedness conditions on inductive data definitions,
such as well-typedness and \emph{strict positivity}\index{strict positivity},
are entirely standard, so I don't detail them here;
see pCIC\index{Calculus of Inductive Constructions!Predicative \textasciitilde}~\citep{pCIC}
for instance for a full description.
Inductive definitions in their full generality are not needed,
and nonmutual, nonnested inductives suffice.
Indeed, only six inductive definitions are used for the translation,
for representing sizes, their order, their well-foundedness,
and the empty type, naturals, and well-founded trees.

The typed equivalence\index{equivalence}, subtyping, and typing judgements are defined mutually:
equivalence depends on typing and subtyping,
subtyping depends on equivalence,
and typing depends on subtyping and equivalence.
The mutual dependence is due to typed equivalence,
since with untyped conversion as seen in \lang has no typing premises.
I present first the equivalence rules in \cref{fig:equivalence},
with the subtyping and typing rules to follow.

Equivalence is, by definition, an equivalence relation,
satisfying reflexivity, symmetry, and transitivity.
Equivalence is also congruent, using the same summary of congruence rules as for \lang via \rref{equiv-cong};
the full set of rules can similarly be found in \cref{app:cong:equiv}.
An equivalence judgement can be converted to one annotated by a supertype via \rref{equiv-conv}.
The key rule for extensionality is equality reflection\index{equality reflection} in \rref{equiv-reflect},
which definitionally equates two terms whenever there exists some proof of their propositional equality.

\FigEquiv{fig:equivalence}

\clearpage
Typed equivalence is required in the presence of equality reflection since
inconsistencies are derivable when using untyped conversion\index{conversion}.
For instance, supposing that \lang had equality reflection and using \new{$\approx$} to denote conversion,
in the empty environment, freely using transivity,
%
\begin{align*}
  \const{0'} &\approx \app{(\fun{p}{\eq{\const{0'}}{\N{\hat{\hat{\circ}}}}{\const{1}}}{\const{0'}})}{\refl{\const{0'}}} &&\textrm{by $\beta$-reduction} \\
  &\approx \app{(\fun{p}{\eq{\const{0'}}{\N{\hat{\hat{\circ}}}}{\const{1}}}{\const{1}})}{\refl{\const{0'}}} &&\textrm{by congruence and reflection of $p$} \\
  &\approx \const{1} &&\textrm{by $\beta$-reduction},
\end{align*}
since reduction and therefore conversion occurs even when its terms are ill-typed,
as the second and third terms are.
An alternate solution would be to disallow transitivity of conversion~\citep{CCE},
but this is too limiting when trying to prove type preservation,
and equivalence would no longer be an equivalence relation.

Untyped conversion with equality reflection also violates subject reduction
under certain environments.
For example, suppose the environment contains the equality $\eq{\arr*{\N{\sss{\circ}}}{\N{\sss{\circ}}}}{}{\arr*{\N{\sss{\circ}}}{\Prop}}$.
Then $\app{(\fun{x}{\N{\sss{\circ}}}{x})}{\const{0}}$ can be assigned type $\Prop$
by equality reflection and conversion of the function's type,
but this term reduces to $\const{0}$ which \emph{cannot} be assigned type $\Prop$.
This can be resolved by adding
\emph{injectivity of type constructors}\index{injectivity of type constructors},
which would allow deriving the equality $\eq{\N{\sss{\circ}}}{}{\Prop}$
from the above, but doing so is generally undesirable since it's inconsistent with
the axioms of both excluded middle and univalence \citep{unification}.

The remaining equivalence rules are typed versions of the usual reduction rules,
with typing premises to ensure well-typedness of both sides.
Functions have both a $\beta$-equivalence rule and an $\eta$-equivalence rule,
the latter of which is only possible since equivalence is typed.
Equivalence rules for $\tg{let}$ expressions are exactly the same as in \lang.
The $\JT*$ eliminator and $\tg{case}$ expressions reduce when applied to
equality and inductive constructors, respectively.

\rref{equiv-mu} for fixpoint expressions is \emph{unguarded}\index{guarded reduction},
meaning that fixpoints are equivalent to the substitution of itself into its own body
regardless of what they are applied to.
To maintain normalization,
the usual guarded reduction rule in intensional CIC reduces fixpoints
only when applied to a literal constructor in the recursive argument position.
\vspace{-0.25\baselineskip}
\begin{mathpar}
\inferrule[\rlabel{$\equiv$-$\mu$-guarded}{equiv-mu-guarded}]{\cdots \\ \card{\vec{\eT}'} + 1 = \nT}{
  \defeq{\GammaT}{\app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\eT}'}{(\app{\cT}{\vec{\aT}})}}{\app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\eT}'}{(\app{\cT}{\vec{\aT}})}}{\tauT}
}
\end{mathpar}

Evidently \rref{equiv-mu-guarded} can be derived from \rref{equiv-mu} by congruence.
On the other hand, for any particular inductive type $\XT$,
letting $\tauT$ be $\arr{\vec{\xT}}{\vec{\sigmaT}}{\funtypeT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\tauT'}}$,
\rref{equiv-mu} can be derived from \rref{equiv-mu-guarded} via reflection of the following provable propositional equality,
freely using transitivity:

\begin{align*}
\fixT{\nT}{\fT}{\tauT}{\eT} &\eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\xT}}{\xT}}}
\qquad \textrm{definitionally by \rref{equiv-eta}} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\matchT*{\xT}{\seq(\app{\cT}{\vec{\zT}} \RightarrowT \app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\xT}}{(\app{\cT}{\vec{\pT}}{\vec{\zT}})})\seq}}} \\
& \phantom{\eq{}{}{}} \textrm{by congruence and case analysis on $\xT$} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\matchT*{\xT}{\seq(\app{\cT}{\vec{\zT}} \RightarrowT \app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\xT}}{(\app{\cT}{\vec{\pT}}{\vec{\zT}})})\seq}}} \\
& \phantom{\eq{}{}{}} \textrm{definitionally by \rref{equiv-cong, equiv-mu-guarded}} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\xT}}{\xT}}} \\
& \phantom{\eq{}{}{}} \textrm{by congruence and case analysis on $\xT$} \\
& \eq{}{}{} \subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}}
\qquad \textrm{definitionally by \rref{equiv-eta}}
\end{align*}

Since \rref{equiv-mu} and \rref{equiv-mu-guarded} are metatheoretically equivalent,
I choose to use \rref{equiv-mu} for its simplicity.

\FigSubtypingCIC{fig:subtyping-cic}
As opposed to \lang, for \CICE I use
pCIC's\index{Calculus of Inductive Constructions!Predicative \textasciitilde}
presentation of subtyping\index{subtyping}, which has a typed equivalence premise in \rref{subtype-conv}.
It also has an explicit rule for transitivity of subtyping since judgements such as
$\subtype{\mt}{\app{(\funT{P}{\TypeT{\tg{1}}}{P})}{\PropT}}{\TypeT{\tg{0}}}$ would fail to hold otherwise.
Like \rref{acum-pi}, \rref{subtype-pi} is invariant in the domain of function types.

The typing and environment well-formedness rules are in \cref{fig:typing-cic}.
Except for \rref{fix*}, the starred rules are the same as for \lang,
with metafunctions $\axioms{\mt}$ and $\rules{\mt}{\mt}$ operating similarly on universes $\UT$
as in \cref{fig:rules-axioms}.
An additional premise to \rref{fix*} ensures that the $\nT$th argument is indeed an inductive type.
% in addition to checking well-typedness of fixpoint bodies with possible recursive references.

As previously mentioned, fixpoints must also be guarded\index{guardedness}:
recursive calls can only occur on structurally smaller arguments of elements of inductives.
The guard condition is well-studied~\citep{guard, guard-relax, Coq} and so omitted here.
To justify uses of fixpoint expressions in the translation,
I will provide either a mechanization or present a brief argument of guardedness.

\FigTypingCIC{fig:typing-cic}

The new \rref{eq, refl, J} are for the propositional equality\index{propositional equality} type,
its constructor, and its eliminator.
Given some equality proof $\pT$ of $\eqT{\eT_1}{\tauT}{\eT_2}$
and a motive $\PT$ dependent on a proof of equality
whose left-hand side is fixed at $\eT_1$ and right-hand side is variable\punctstack{,}%
\footnote{Occasionally referred to as \emph{Paulin-Mohring}'s equality,
as opposed to \emph{Martin-L\"of}'s equality
where the left-hand side is variable as well.}
to prove $\app{\PT}{\eT_2}{\pT}$ it suffices to provide to $\JT*$ a proof that
$\app{\PT}{\eT_1}{\refl{\eT_1}}$ holds.
Other usual functions on proofs of equality can be derived from it,
such as coercion (when the motive is \mbox{$\funT{A}{\UT}{\funT{\any}{\any}{A}}$})
or substitution (when the motive ignores the second argument),
as well as its symmetry, transitivity, and congruence.
The proof of type preservation eliminates propositional equalities mostly through
reflection\index{equality reflection} rather than using $\JT*$,
but I retain $\JT*$ in \CICE for completeness\punctstack{.}%
\footnote{The combined presence of $\JT*$ and equality reflection also allows proving the
\emph{uniqueness of identity proofs} (UIP)\index{uniqueness of identity proofs},
or that all proofs of an equality are themselves equal to one another.}

\rref{ind, constr, case} assign types to inductive types, their constructors,
and $\tg{case}$ expressions, under the premise that
the relevant inductive data definition exists and is well-formed.
Here, the difference between the parameters and the indices of inductive types becomes apparent:
the motive\index{motive} of a $\tg{case}$ expression is abstracted over the indices by $\vec{\yT}$
in addition to the target by $\xT$, while the parameters $\vec{\pT}$ are fixed throughout.
Therefore, when dealing with the types of indices and constructor arguments,
the parameters are first substituted in place of $\vec{\wT}$.

A $\tg{case}$ expression is well typed if its target is, if its motive is for any indices and according target,
and if each branch is well typed for that branch's constructor arguments,
where its type is the motive with the appropriate indices and reconstructed target.
For notational simplicity, the rule assumes that the binding variable names
$\vec{\yT}$ and $\vec{\zT}$ are those found in the data definition,
but of course these can be renamed at the expense of additional renaming substitutions.

Additionally, the motive of a $\tg{case}$ expression is restricted by the metarelation $\elim{\mt}{\mt}{\mt}$,
which indicates when \emph{large elimination}\index{large elimination} is allowed.
More precisely, $\elim{\any}{\TypeT{\iT}}{\any}$ and $\elim{\any}{\PropT}{\PropT}$ always hold,
so that inductives in $\TypeT{}$ can be eliminated to any universe
and inductives in $\PropT$ can be eliminated to $\PropT$,
while $\elim{\XT}{\PropT}{\TypeT{\iT}}$ holds if the inductive $\XT$ in $\PropT$ satisfies further conditions.
For the purposes of the translation, the only relevant conditions are that $\XT$ either have no constructors
or have a single constructor whose arguments are all in $\PropT$.
They can be loosened while still retaining consistency (see \eg \citet{SProp}).

The typing premises of
\rref{equiv-beta, equiv-zeta, equiv-rho, equiv-iota, equiv-mu}
corresponding to some of the reduction rules duplicate the premises found in many of the typing rules,
trivially ensuring that both sizes of these equivalences are well-typed with the same type
(a property known as \emph{subject equivalence}\index{subject reduction}).

\section{Preliminary Definitions}

Before defining the translation from \lang terms to \CICE terms,
in this section I describe how the \CICE terms are constructed,
which comprises the aforementioned six inductive data definitions
and well-founded induction principle
as well as the various properties which the order on sizes satisfies.

\FigData{fig:data-defns}

The inductive definitions are listed in \cref{fig:data-defns}
along with some basic definitions I treat as global.
$\botT$ is the usual empty type.
$\SizeT$ is a generalization of the $\Ord*$ type introduced in \cref{sec:examples},
with the domain of the function passed to the limit size $\limT$ replaced by some arbitrary type.
Although limit sizes aren't strictly necessary for the translation,
since \lang only has successor sizes and size variables,
I include them so that various solutions to the problem of the infinite size
can be explored in \cref{sec:infinity}.
Furthermore, this allows for a simplification of the definition,
since the zero size $\baseT$ can be defined as a limit size rather than as another constructor.

The order on sizes $\mt \szleT \mt$ is defined by the three properties that must hold~\citep{ordinals}:
\begin{itemize}[noitemsep]
  \item $\monoT$: The successor operator $\sucT$ is monotone with respect to the order;
  \item $\coconeT$: The limit operator $\limT$ constructs an upper bound in that
    given some function $f$ returning a size,
    any size smaller than any size returned by $f$ is also smaller that the limit of $f$;
  \item $\limitT$: The limit operator on $f$ constructs a \emph{least} upper bound such that
    if a size is larger than \emph{all} sizes returned by $f$
    then it must also be larger than the limit of $f$.
\end{itemize}

Other properties of the order can be derived by induction from these constructors alone.
A corresponding strict order $\mt \szltT \mt$ is also defined,
and an accessibility predicate\index{accessibility predicate} $\AccT$ is specialized to sizes and the strict order.
Note that it lives in $\PropT$, as does the argument of its sole constructor $\accT$,
so accessibility predicates are intended to be interpreted as proof-irrelevant\index{proof irrelevance},
and their large elimination\index{large elimination} is allowed.

\FigDefns{fig:defns}

Before moving on to naturals and well-founded trees,
\cref{fig:defns} lists the names and types of a number of provable definitions.
First is \emph{function extensionality}\index{function extensionality},
asserting that two functions $\annot{f, g}{\funtypeT{x}{A}{\app{B}{x}}}$ are propositionally equal if they are pointwise equal.
In \CICE, they are in fact equivalent (\ie definitionally equal):
given some proof $h$ of their pointwise equality,
under the assumption $\annot{x}{A}$,
the propositional equality $\eq{\app{f}{x}}{}{\app{g}{x}}$ by $\app{h}{x}$
can be reflected into the corresponding definitional equality,
which by \rref{equiv-eta} is then a definitional equality of $f$ and $g$.

The remaining definitions have been mechanized in either Agda and Coq in
\cref{app:mechanization:agda:prelim} and \cref{app:mechanization:coq:prelim}, respectively,
under the assumption of function extensionality as an axiom
(which cannot be proven in intensional CIC).
The mechanizations don't use any additional type-theoretic features beyond CIC,
and the proofs could theoretically be written in plain CIC,
but they would be far less comprehensible without the ergonomics provided by the proof assistants.
As an example, the Coq proof for $\accessible$ consists of a dozen lines of tactics,
while the full proof term generated from the tactics is 129 lines long.

The definitions themselves describe properties of the order on sizes
and of the accessibility predicate:
\begin{itemize}[noitemsep]
  \item $\baseleq$, $\reflleq$, $\transleq$, and $\sucleq$:
    The order is reflexive and transitive (\ie a preorder)
    such that $\baseT$ is smaller than or equal to all sizes
    and the successor of a size is greater or equal to itself.
  \item $\accIsProp$: Accessibility predicates are \emph{mere propositions}\index{mere proposition}:
    any two proofs of accessibility of a size are propositionally equal.
  \item $\accleq$: Any size smaller or equal to an accessible size is itself accessible.
  \item $\accessible$: All sizes are accessible; in other words, the order on sizes is well founded.
  \item $\wfind$ and $\wfacc$: The well-founded induction principle\index{well-founded induction} on sizes with respect to the order,
    proven by structural induction on the accessibility of sizes.
\end{itemize}

The only time equality reflection\index{equality reflection} is needed is to prove $\accIsProp$ (via $\funext$),
which in turn is the only other equality that is reflected for proving type preservation.
Since $\AccT$ is in already $\PropT$, \CICE could be replaced by an intensional CIC
with a universe of \emph{strict propositions}\index{strict proposition} $\SPropT$
of types whose elements are definitionally equal~\citep{SProp},
then placing $\AccT$ in $\SPropT$.
This is disallowed by \opcit because it breaks normalization,
but not consistency which,
as a target language of a syntactic model for proving consistency,
is the relevant metatheoretical property.
In any case, I use \CICE because equality reflection is more established in the literature
and it allows me to use \rref{equiv-mu} in place of \rref{equiv-mu-guarded}.

Finally, the naturals and the well-founded trees in \CICE are parametrized by a $\SizeT$.
Their definitions respect the translation in the upcoming section,
so that the types of $\NatT$ and $\WT$ and their constructors are preserved.

\section{Translation}

The key type preservation\index{type preservation} theorem states that well-typed terms of \lang translate to
corresponding well-typed terms of CICE.
However, terms are not the only thing requiring translation:
well-typedness holds under some environment, so term environments need translations;
sizes and their environments translate to terms and term environments as well;
and derivations of size orders translate to terms which represent them.

\FigTransSize{fig:trans:size}
I begin with the translation of sizes and their environments in \cref{fig:trans:size},
which are straightforward recursive metafunctions over their syntax.
I use an asterisk superscript \new{$\mt^\ast$} on a variable $\alphaT$ to represent
a fresh variable uniquely associated with $\alphaT$.
Given some bound size variable $\alphaT$,
$\alphaT^\ast$ represents the proof that the translated size is strictly smaller
than its size bound.

\FigTransSubsize{fig:trans:subsize}
The translation of subsizing judgements, on the other hand,
is a recursive metafunction over the \emph{subsizing derivation}.
\cref{fig:trans:subsize} defines the translation to \CICE terms
by induction on the subsizing rules, which recursively translates subderivations
(omitting size well-scopedness premises).

The translation of terms and term environments are similarly defined
as recursive metafunctions over the typing and well-formedness derivations,
denoted by
\mbox{$\typeto{\Phi, \Gamma}{e}{\tau}{\eT}$} and \mbox{$\wfto{\Phi}{\Gamma}{\GammaT}$}
respectively.
However, for concision, I use $\compile{e}$ to mean the translation of $e$
when well-typed under the current implicit environments,
$\compile{e}_{\Phi}$ or $\compile{e}_{\Gamma}$ to mean the translation of $e$
with the current implicit environments extended with $\Phi$ or $\Gamma$,
and $\compile{\Gamma}$ to mean the translation of $\Gamma$
when well-formed under the current implicit size environment.

\FigTransTerm{fig:trans:term}

The translation for base \lang without inductives is given in \cref{fig:trans:term}
in the more concise notation when the intent is clear and in the usual notation otherwise.
Terms not involving sizes are translated in a straightforward recursive manner.
Unbounded size quantifications and abstractions translate to quantifications and abstractions over $\SizeT$,
while bounded ones have additional quantifications and abstractions over a proof of $\szltT$.
Size applications translate to an additional application to a proof of $\szltT$
when the size abstraction applied is bounded.

Finally, \cref{fig:trans:ind} gives the translation for naturals, well-founded trees,
$\kw{case}$ expressions, and fixpoint expressions from their typing derivations
to a \CICE term (again omitting irrelevant premises).
Aside from fixpoints, the translations are fairly straightforward,
with an additional proof term from subsizing for constructors
and dually an additional abstraction over such terms in the branches of $\tg{case}$ expressions.

\FigTransInd{fig:trans:ind}

Fixpoints in \lang are not translated as fixpoints in \CICE.
Doing so while preserving types would mean that \lang fixpoints
need to be subject to the same guard conditions as \CICE fixpoints,
which is clearly undesirable and not the case in the examples from \cref{sec:examples}.
Instead, every single \lang fixpoint, regardless of the inductive on which they recur,
is translated to well-founded induction\index{well-founded induction},
which is defined via a \CICE fixpoint on accessibility predicates\index{accessibility predicate}.
Intuitively, the return type of a fixpoint corresponds to the motive of well-founded induction,
while recursion on a strictly smaller size corresponds to the induction hypothesis,
where the motive holds for all strictly smaller sizes.

The main challenge with this translation is showing that the translations of a fixpoint
and of its $\mu$-reduction are equivalent in \CICE,
because this requires showing that the computational behaviour of well-founded induction
is equivalent to the computational behaviour of the fixpoint.
Once that has been established,
showing type preservation of the translation is more or less going through the motions of the proof,
since the remaining \lang terms translate almost directly to their syntactically corresponding terms.