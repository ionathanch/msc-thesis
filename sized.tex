\chapter{Sized Dependent Types} \label{ch:sized-dep-types}

\input{figures/sized.tex}
\input{figures/ind.tex}

% TODO: explain metanotation (..., _, Â·)
% TODO: remember to mention that new notation not in a figure is highlighted in grey

\section{Base \lang}

Although sized types are quite pointless without any inductive types to be sized,
I present in this subsection the sublanguage of \lang without naturals or well-founded trees
to not only get the preliminary details out of the way first,
but also to show that the sublanguage is independent of the chosen inductive types.

\FigSyntax{fig:syntax}
\cref{fig:syntax} gives its syntax, which consists of universes $U$,
sizes $s$, and terms $e$, which includes term functions, size abstractions,
and the propositional equality type.
Most judgements use two environments: a term environment $\Gamma$ with assumptions $\annot{x}{\tau}$
and definitions $\define{x}{e}$, and a size environment $\Phi$ with unbounded and bounded size variables.
I also use the assumption environment%
\footnote{These are conventionally called \emph{telescopes}\index{telescopes} due to \citet{telescope}.}
$\Delta$ as a shorthand when writing nested expressions with assumptions;
in particular, letting for instance $\Delta_{xy} = \annot{x}{\sigma_1}, \annot{y}{\sigma_2}$,
I use \new{$\arr*{\Delta_{xy}}{\tau}$} to mean $\funtype{x}{\sigma_1}{\funtype{y}{\sigma_2}{\tau}}$.
As a loose convention, I use $\tau, \sigma$ for type-like terms,
$P$ for the \emph{motive}\index{motive} of eliminators,
$p$ for proofs of equality, and
$f, g$ for variables representing functions.

\clearpage % TODO: make sure this is still needed later
As mentioned in \cref{ch:overview}, the judgement forms of \lang include
reduction, its various closures, $\alpha$-cumulativity, subtyping, and typing.
On top of those, there are also judgement forms for subsizing, sizes,
and well-formedness of size and term environments.

\FigRed{fig:reduction}
The reduction rules and their reflexive, transitive, congruent closures are described in \cref{fig:reduction}.
\new{$\subst{e}{x}{e'}$} denotes capture-avoiding substitution of $x$ for $e'$ within $e$,
and \new{$\subst{e}{x_1, \seq, x_n}{e_1, \seq, e_n}$} correspondingly denotes simultaneous substitution.
For every syntactic form of a term there is a corresponding congruence rule,
which is summarized by \rref{red*-cong};
the full set of rules can be found in \TODO. % put them in the appendix
By convention, the reduction rules for functions are also referred to as $\beta$-reduction,
for $\kw{let}$ expressions as $\zeta$-reduction,
and for defined variables as $\delta$-reduction.
\iffalse % this got too long
\footnote{In MLTT, all rules consisting of an elimination form around an introduction form
are referred to as $\beta$-reduction,
which would include the reduction rule for $\J*$, not just functions.
On the other hand, in type theories where propositional equality is defined as a inductive type,
the reduction rule would be called $\iota$-reduction.
I avoid this dilemma by not referring to the reduction rule for $\J*$ by name at all.}
\fi

These rules can be thought of as a description of nondeterministic evaluation of open terms,
``running'' from the left term to the right.
I separate them into reduction rules proper and closure rules so that the proof structure is more modular:
the cases for the reduction rules have much more in common with each other than, say, those of the congruence rules,
and the cases for the congruence rules require extra hypotheses that those of the reduction rules don't.
This is also the convention for untyped reduction used by \eg \citet{wjb}.

\FigSubtype{fig:subtyping}
Rather than a single subtyping judgement, such as in the
predicative Calculus of Cumulative Inductive Constructions
\index{predicative Calculus of Cumulative Inductive Constructions}
(pCuIC)~\citep{pCuIC},
I use the same presentation as MetaCoq\index{MetaCoq}~\citep{MetaCoq}
and split it into a subtyping judgement
and a separate $\alpha$-cumulativity\index{$\alpha$-cumulativity} judgement,
listed in \cref{fig:subtyping}.
This overcomes some technical proof complications that appear in
the single-judgement presentation due to the transitivity rule.
Aside from the expected cumulativity of universes,
the function type and size quantification are covariant in the codomain
(\ie are $\alpha$-cumulative when their codomains are),
while remaining invariant in the domain.%
\footnote{The domain could be made contravariant instead if function type subtyping
in \CICE were similarly contravariant,
but to my knowledge, there is no such variant of CIC with untyped conversion
and without $\eta$-conversion that has been proven consistent.}
All other types are invariant, as reflected by \rref{acum-refl}.
A term is then a subtype of another if they are confluent up to $\alpha$-cumulativity.
% Conversion can be defined as the confluence of two terms,
% but conversion isn't needed for any judgements so I exclude the definition.

Notably, \lang does \emph{not} have a notion of $\eta$-conversion
in either the reduction rules or in the subtyping rules,
which would otherwise allow conversion between $\fun{x}{\tau}{\app{f}{x}}$ and $f$.
Mixing $\eta$-conversion and untyped converion is notoriously difficult~\citep{eta},
and remains an unresolved problem in MetaCoq, so I exclude it here.

\FigSubsize{fig:subsizing}
\cref{fig:subsizing} describes a preorder on sizes such that
the successor operator is monotonic with respect to the order.
The base size $\circ$ is smaller than all sizes,
and the strict preorder $\bound{\alpha}{s}$ arising from bounded quantification or abstraction
is defined as $\sss{\alpha} \mathrel{\leqslant} s$.
An additional size judgement ensures well-scopedness of sizes.
The size environment must be well formed as well;
its rules are listed in \cref{fig:wf},
along with those for well-formedness of term environments.
\FigWF{fig:wf}

\FigRulesAxioms{fig:rules-axioms}
\FigTyping{fig:typing}
Finally, the typing rules for the base \lang are given in \cref{fig:typing}.
They use the metafunctions $\axioms{\mt}$ for the type of a universe
$\rules{\mt}{\mt}$ for the type of a function type,
defined in \cref{fig:rules-axioms},
and $\fresh{\seq}$ for fresh variables.

\rref{var, univ, let} are the usual rules for variables, universes, and $\kw{let}$ expressions
in \GCC,\index{Calculus of Constructions!generalized \textasciitilde}
while \rref{pi, lam, app} are the usual ones for functions.
The $\Prop$ universe is impredicative\index{impredicativity} because
a function type quantifying over any type is itself in $\Prop$
as long as its codomain is as well,
allowing a restricted form of circularity.
For example, a function $\id \mathrel{\coloneqq} \fun{\tau}{\Prop}{\fun{x}{\tau}{x}}$
can be assigned the type $\Id \mathrel{\coloneqq} \funtype{\tau}{\Prop}{\arr*{\tau}{\tau}}$ in $\Prop$
and applied to its own type and itself to yield $\app{\id}{\Id}{\id}$
of type $\Id$.

\rref{conv} uses the subtyping judgement and essentially allows casting a term
from one type to a supertype as needed.
If we were working in a bidirectional presentation,
where the typing judgement is replaced by either
\emph{type checking}, which checks an input term against and input type,
or \emph{type synthesis}, which synthesizes an output type for an input type,
this rule for $\type{\Phi; \Gamma}{e}{\tau}$ would be the sole checking rule,
first synthesizing types $\sigma$ and $U$ for $e$ and $\tau$ respectively,
then checking $\sigma$ against $U$,
and at last asserting that $\sigma$ is indeed a subtype of $\tau$.
This is why, despite $\type{\Phi; \Gamma}{\sigma}{U}$ being derivable,
I choose to retain it as a premise.

\clearpage % TODO: make sure this is still needed later
\rref{forall, forall<, slam, slam<, sapp, sapp<} are the new rules relevant to sized types,
describing bound and unbound size quantification, abstraction, and application,
which work similarly to functions.
Of note is the bounded size application rule,
which only allows applications to smaller sizes following the subsizing judgement.

Lastly are \rref{eq, refl, J} for propositional equality.
The constructor $\refl{e}$ is a reflexive proof of $\eq{e}{\tau}{e}$,
that $e$ of type $\tau$ is equal to itself.
Given some equality proof $p$ of $\eq{e_1}{\tau}{e_2}$
and a motive\index{motive} $P$ taking some $y$ of type $\tau$ and a proof that $\eq{e_1}{\tau}{y}$,
the $\J*$ eliminator is a proof of $\app{P}{e_2}{p}$ when provided a proof of $\app{P}{e_1}{\refl{e_1}}$.
Other usual functions on proofs of equality can be derived from it,
such as coercion (when the motive is a constant function on types in its first argument)
or substitution (when the motive ignores the second argument).
$\J*$ is only well typed when fully applied;
it can be manually uncurried for a specific universe $U$ as the function
\marginnote{The type annotation for the equality type and argument to $\refl{}$ may be omitted when evident from context.}
$$\fun{\tau}{U}{\fun{e_1}{\tau}{\fun{e_2}{\tau}{\fun{P}{(\funtype{y}{\tau}{\funtype{z}{\eq{e_1}{}{y}}{U}})}{\fun{d}{\app{P}{e_1}{\refl{}}}{\fun{p}{\eq{e_1}{}{e_2}}{\J{P}{d}{p}}}}}}},$$
and similarly for $\refl{}$.

\section{Inductive Types: Naturals and Well-Founded Trees}\label{sec:ind-types}

\FigSyntaxInd{fig:syntax-ind}
\cref{fig:syntax-ind} extends the grammar with sized naturals, sized well-founded trees,
$\kw{case}$ expressions, and fixpoint expressions.
Informally, borrowing syntax from the definition of general inductives,
sized naturals and well-founded trees can be thought of as being defined by the following:
%
\begin{align*}
&\data*{\annot{\N{\alpha}}{\Type{1}}} && \data*{\annot{\app{\App{\W*}{\alpha}}{(\annot{A}{\Type{i}})}{(\annot{B}{\arr*{A}{\Type{i}}})}}{\Type{i}}} \\
&\quad \annot{\zero*}{\Funtype<{\beta}{\alpha}{\N{\alpha}}} && \quad \annot{\sup*}{\Funtype<{\beta}{\alpha}{\arr{x}{A}{\arr*{(\arr*{\app{B}{x}}{\app{\App{\W*}{\beta}}{A}{B}})}{\app{\App{\W*}{\alpha}}{A}{B}}}}} \\
&\quad \annot{\succ*}{\Funtype<{\beta}{\alpha}{\arr*{\N{\beta}}{\N{\alpha}}}}
\end{align*}
%
The types of naturals and well-founded trees can then be considered to be (nonuniformly) parametrized by a size,
and constructing an element of that type requires providing a strictly smaller size,
which is the size of the constructor's recursive arguments.
Constructors therefore always construct elements whose sizes are larger than their arguments'.
\marginnote{The ``size of'' some construction is more precisely the size by which its \emph{inductive type} is parametrized.}
In \lang, the constructors are annotated with their types
since the parameter-like sizes cannot otherwise be synthesized.
Additionally, the types of well-founded trees have explicit binders for convenience:
the variable $x$ is bound within $\tau$ in the type $\W{x}{\sigma}{\tau}{s}$.

The expression
$\match{e}{\fun*{x}{P}}{(\app{\App{c}{\alpha}}{z_1}{\seq}{z_m} \Rightarrow e_c) \seq}$
contains three parts (using \new{\meta{\ldots}}
to denote a repeated sequence of some syntactic construct):
the \emph{target}\index{target} $e$ it destructs,
the motive\index{motive} $P$ denoting the return type of the expression abstracted over a target,
and the \emph{branches}\index{branch} $e_c$, one for each constructor of the target's type,
abstracted over the constructor's size and term arguments.
Its reduction rules for each constructor are given in \cref{fig:reduction-ind},
along with the reduction rule for fixpoint expressions;
irrelevant syntactic elements are omitted with \new{$\any$}.
By convention, the reduction rules for $\kw{case}$ expressions are also referred to as $\iota$-reduction,
and for fixpoint expressions as $\mu$-reduction.
\FigRedInd{fig:reduction-ind}

Fixpoints reduce when applied to some size $s$ by substitution of itself into its own body.
Fixpoints' bodies are well typed when recursive applications occur only on smaller sizes,
so the substitution wraps itself in a bound size abstraction.
Most importantly, they reduce only when there exists some size strictly smaller than $s$;
intuitively, this restriction prevents fixpoints from reducing indefinitely
because subsizing is well founded, and there cannot be an infinite chain of smaller sizes.

This reduction strategy supersedes the usual restriction that fixpoints only reduce
when applied to a constructor,
since all sized constructors carry a smaller size argument
that will statisfy the subsizing premise.
Furthermore, reduction can also occur when the fixpoint is applied to a successor size
by reflexivity of subsizing,
making the rule a strict supersession.

\FigTypingInd{fig:typing-ind}

The typing rules for all new constructs are given in \cref{fig:typing-ind}.
One additional metafunction $\FV{\mt}$ produces the free variables in the given term.
The type of naturals and well-founded trees are well typed
when the sizes they are applied to are well formed, and
their constructors are well typed when applied to smaller sizes.

$\kw{case}$ expressions match on these size arguments in addition to the usual term arguments,
asserting within their branches that they are strictly smaller than the target's size.
The motive is dependent on the target,
and the type of a branch is the motive with its target as the constructor being destructed.
In other words, $\kw{case}$ expressions are induction principles:
for instance, one proves $P$ for some natural $x$ when one can prove it
for the base case where $x$ is some $\zero*$
and for the step case where $x$ is some $\succ*$.

As discussed, the body of a fixpoint is only well typed
when the fixpoint is recursively applied to a smaller size,
as enforced by its type in the environment when type checking the body.

Sizes aside, the only difference from regular, unsized naturals and well-founded trees
is that their types live in a universe one level higher than they usually are.
$\N{s}$ lives in $\Type{1}$ rather than in $\Type{0}$,
and $\W{x}{\sigma}{\tau}{s}$ lives in $\axioms{U}$ rather than in $U$.
This is a direct consequence of the way that the translation is defined,
and is necessary to maintain its type preservation properties.
While not incorrect, inductive types living in the ``wrong'' universe is aesthetically unpleasant
and removes some of the impredicativity of their parameters
by preventing them from quantifying over the inductive types themselves.
I discuss potential methods of circumventing this undesirable trait to varying degrees of success
later in \TODO.
% TODO: forward reference to the chapter

\section{Examples}

Now that the rules of \lang have been establish,
this section presents examples of using \lang
for programming and proving.
Although it only has naturals and well-founded trees,
I also use other sized inductive types as examples,
informally defining them similarly to \cref{sec:ind-types}.

\subsection{Concrete natural numbers}

Concrete numbers can be constructed easily using the base size $\circ$ as a starting point
and its successors as strictly larger sizes.
For convenience, I use the notation \new{$s+n$} for some fixed $n$ to mean the $n$th size successor of $s$.
The same number can be represented as terms of different types by changing the annotation since,
for instance, both $\circ+2$ and $\circ+3$ are strictly larger than $\sss{\circ}$.
Similarly, two different numbers can have the same size
because the size of an inductive type represents \emph{at most}
how many layers of constructors deep an element is.
%
\begin{alignat*}{4}
&\Let{\const{0}&&}{\N{\sss{\circ}}&&}{\zero{\hat{\circ}}{\circ}} \\
&\Let{\const{0'}&&}{\N{\circ+2}&&}{\zero{\circ+2}{\circ}} \\
&\Let{\const{1}&&}{\N{\circ+2}&&}{\succ{\circ+2}{\hat{\circ}}{\const{0}}} \\
&\Let{\const{1'}&&}{\N{\circ+3}&&}{\succ{\circ+3}{\hat{\circ}}{\const{0}}} \\
\end{alignat*}

Two terms representing the same number might not be definitionally equal,
as shown by the terms $\const{0}$ and $\const{0'}$,
or by $\const{1}$ and $\const{1'}$;
this requires \emph{shape irrelevance}\index{shape irrelevance}~\citep{NbE},
which is beyond the scope of this thesis.
However, any number can be ``lifted'' to a larger size
simply by recursively reconstructing the number with different sizes.

\begin{align*}
&\Let{\const{liftN}}{\Funtype{\alpha}{\Funtype<{\beta}{\alpha}{\arr*{\N{\beta}}{\N{\alpha}}}}}{\\
&\fix{}{\mathit{lift}}{\alpha}{\Funtype<{\beta}{\alpha}{\arr*{\N{\beta}}{\N{\alpha}}}}{\\
&\quad \Fun<{\beta}{\alpha}{\fun{n}{\N{\beta}}{\\
&\quad \match{n}{\fun*{\any}{\N{\alpha}}}{\\
&\qquad \App{\zero*}{\gamma} \Rightarrow \zero{\alpha}{\beta} \\
&\qquad \app{\App{\succ*}{\gamma}}{z} \Rightarrow \succ{\alpha}{\beta}{(\app{\App{\mathit{lift}}{\beta}{\gamma}}{z})}}}}}}
\end{align*}

A lifting function can also be defined for well-founded trees,
and for strictly-positive inductive types in general.
%
\begin{align*}
&\Let{\const{liftW}}{\funtype{A}{\Type{i}}{\funtype{B}{\arr*{A}{\Type{i}}}{\Funtype{\alpha}{\Funtype<{\beta}{\alpha}{\arr*{\W{x}{A}{\app{B}{x}}{\beta}}{\W{x}{A}{\app{B}{x}}{\alpha}}}}}}}{\\
&\fun{A}{\Type{i}}{\fun{B}{\arr*{A}{\Type{i}}}{\\
&\fix{}{\mathit{lift}}{\alpha}{\Funtype<{\beta}{\alpha}{\arr*{\W{x}{A}{\app{B}{x}}{\beta}}{\W{x}{A}{\app{B}{x}}{\alpha}}}}{\\
&\quad \Fun<{\beta}{\alpha}{\fun{w}{\W{x}{A}{\app{B}{x}}{\beta}}{\\
&\quad \match{w}{\fun*{\any}{\W{x}{A}{\app{B}{x}}{\alpha}}}{\\
&\qquad \app{\App{\sup*}{\gamma}}{a}{f} \Rightarrow \sup{x}{A}{\app{B}{x}}{\alpha}{\beta}{a}{(\fun{x}{A}{\app{\App{\mathit{lift}}{\beta}{\gamma}}{(\app{f}{x})}})}}}}}}}}
\end{align*}

\iffalse
\begin{align*}
\Let{&\const{liftW}}{\funtype{A}{\Type{i}}{\funtype{B}{\arr*{A}{\Type{i}}}{\Funtype{\alpha}{\Funtype<{\beta}{\alpha}{\arr*{\W{x}{A}{\app{B}{x}}{\beta}}{\W{x}{A}{\app{B}{x}}{\alpha}}}}}}}{\\
&\const{liftW} \: A \: B \: [\alpha] \: [\beta] \: (\app{\App{\sup*}{\gamma}}{a}{f}) = \sup* \: [\beta] \: a \: (\fun{x}{A}{\const{liftW} \: A \: B \: [\beta] \: [\gamma] \: (\app{f}{x})})}
\end{align*}
\fi

\subsection{Size-preserving functions}

One of the most important uses of sized types is the ability to define
\emph{size-preserving}\index{size preservation} functions,
where the sizes of the input and output are the same.
This guarantees that the output is never larger than the input,
and size-preserving functions can be used in recursive calls of fixpoints.
For instance, the predecessor function $\const{pred}$ which computes
$\maximum{0, n - 1}$ for some number $n$ is size preserving.
%
\begin{align*}
&\Let{\const{pred}}{\Funtype{\alpha}{\arr*{\N{\alpha}}{\N{\alpha}}}}{\\
&\Fun{\alpha}{\fun{n}{\N{\alpha}}{\match*{n}{\\
&\quad \App{\zero*}{\beta} \Rightarrow \zero{\alpha}{\beta} \\
&\quad \app{\App{\succ*}{\beta}}{m} \Rightarrow \app{\App{\const{liftN}}{\alpha}{\beta}}{m}}}}}
\end{align*}

The $\const{monus}$ function, which computes $\maximum{0, n - m}$ given numbers $n, m$,
is similarly size preserving in its first argument,
since $n - m$ is never greater than $n$.

\begin{align*}
&\Let{\const{monus}}{\Funtype{\alpha}{\Funtype{\beta}{\arr*{\N{\beta}}{\N{\alpha}}{\N{\beta}}}}}{\\
&\fix{}{\mathit{monus}}{\alpha}{\Funtype{\beta}{\arr*{\N{\beta}}{\N{\alpha}}{\N{\beta}}}}{\\
&\quad \Fun{\beta}{\fun{n}{\N{\beta}}{\fun{m}{\N{\alpha}}{\match*{m}{\\
&\qquad \App{\zero*}{\gamma} \Rightarrow n \\
&\qquad \app{\App{\succ*}{\gamma}}{k} \Rightarrow \app{\App{\mathit{monus}}{\gamma}{\beta}}{(\app{\App{\const{pred}}{\beta}}{n})}{k}}}}}}}
\end{align*}

We see the benefit of size preservation with $\const{div}$,
which computes Euclidean division of $n$ by $m$, or $\left\lceil\frac{n}{m+1}\right\rceil$.
This is computed recursively by subtracting $m$ from the numerator using $\const{monus}$
until $\zero*$ is reached, and counting the number of times the subtraction is performed.
The recursive call is done on the result of $\const{monus}$;
$\const{div}$ then only type checks because $\const{monus}$ is size preserving.
Because the first argument of the recursive call to $\const{div}$ isn't \emph{structurally}
a subterm with the call to $\const{monus}$ in the way,
the corresponding unsized function in a language whose fixpoints
check for structurally-decreasing arguments (such as CIC)
would not be accepted.

\begin{align*}
&\Let{\const{div}}{\Funtype{\alpha}{\Funtype{\beta}{\arr*{\N{\alpha}}{\N{\beta}}{\N{\alpha}}}}}{\\
&\fix{}{\mathit{div}}{\alpha}{\Funtype{\beta}{\arr*{\N{\alpha}}{\N{\beta}}{\N{\alpha}}}}{\\
&\quad \Fun{\beta}{\fun{n}{\N{\alpha}}{\fun{m}{\N{\beta}}{\match*{n}{\\
&\qquad \App{\zero*}{\gamma} \Rightarrow \zero{\alpha}{\gamma} \\
&\qquad \app{\App{\succ*}{\gamma}}{k} \Rightarrow
\succ{\alpha}{\gamma}{
  (\underbrace{\app{\App{\const{div}}{\gamma}{\beta}}{
    (\underbrace{\app{\App{\const{monus}}{\beta}{\gamma}}{k}{
      (\underbrace{\app{\App{\const{pred}}{\beta}}{m}}_{\N{\beta}})
    }}_{\N{\gamma}})
  }{m}}_{\N{\gamma}})
}}}}}}}
\end{align*}

\subsection{Large sized functions}

So far, none of these examples have made use of dependent types:
their unsized variants could have all been written in System F.
We therefore now turn to the $n$-ary size-preserving function type,
which does \emph{large elimination}\index{large elimination}
on a natural $n$, \ie returns a type.
This example is due to \citet{MiniAgda}.

\begin{align*}
&\Let{\const{Nary}}{\Funtype{\alpha}{\arr*{\N{\alpha}}{\Funtype{\beta}{\Type{1}}}}}{\\
&\fix{}{\mathit{nary}}{\alpha}{\arr*{\N{\alpha}}{\Funtype{\beta}{\Type{1}}}}{\\
&\quad \fun{n}{\N{\alpha}}{\Funtype{\beta}{\match{n}{\fun*{\any}{\Type{1}}}{\\
&\qquad \App{\zero*}{\beta} \Rightarrow \N{\beta} \\
&\qquad \app{\App{\succ*}{\beta}}{m} \Rightarrow \arr*{\N{\beta}}{\App{\app{\mathit{nary}}{m}}{\beta}}}}}}}
\end{align*}

Intuitively, $\const{Nary}$ constructs the function type

$$\App{\app{\App{\const{Nary}}{\alpha}}{n}}{\beta} = \arr*{\underbrace{\arr*{\N{\beta}}{\seq}{\N{\beta}}}_{\text{$n$ arguments}}}{\N{\beta}}.$$

$n$-ary size-preserving functions can then be typed using $\const{Nary}$,
such as a $\const{maximum}$ function that takes the maximum of $n+1$ numbers
all of the same size.
For concision I define $\const{max}$ in a pattern-matching style of syntax,
but it can easily be translated to proper \lang as a fixpoint and two $\kw{case}$ expressions.

\begin{align*}
\Let{&\const{max}}{\Funtype{\alpha}{\arr*{\N{\alpha}}{\N{\alpha}}{\N{\alpha}}}}{\\
&\const{max} \: \sqbr{\alpha} \: n \: (\App{\zero*}{\beta}) = n \\
&\const{max} \: \sqbr{\alpha} \: (\App{\zero*}{\beta}) \: m = m \\
&\const{max} \: \sqbr{\alpha} \: (\app{\App{\succ*}{\beta}}{n'}) \: (\app{\App{\succ*}{\beta}}{m'}) = \succ{\alpha}{\beta}{(\app{\App{\const{max}}{\beta}}{n'}{m'})}}
\end{align*}
\iffalse
\begin{align*}
&\Let{\const{max}}{\Funtype{\alpha}{\arr*{\N{\alpha}}{\N{\alpha}}{\N{\alpha}}}}{\\
&\fix{}{\mathit{max}}{\alpha}{\arr*{\N{\alpha}}{\N{\alpha}}{\N{\alpha}}}{\\
&\quad \fun{n}{\N{\alpha}}{\fun{m}{\N{\alpha}}{\\
&\quad \match*{n}{\\
&\qquad \App{\zero*}{\beta} \Rightarrow m \\
&\qquad \app{\App{\succ*}{\beta}}{n'} \Rightarrow \\
&\qquad \quad \match*{m}{\\
&\qquad \qquad \App{\zero*}{\beta} \Rightarrow n \\
&\qquad \qquad \app{\App{\succ*}{\beta}}{m'} \Rightarrow \succ{\alpha}{\beta}{(\app{\App{\mathit{max}}{\beta}}{n'}{m'})}}}}}}}
\end{align*}
\fi
%
\begin{align*}
&\Let{\const{maximum}}{\Funtype{\alpha}{\funtype{k}{\N{\alpha}}{\Funtype{\beta}{\arr*{\N{\beta}}{\App{\app{\App{\const{Nary}}{\alpha}}{k}}{\beta}}}}}}{\\
&\fix{}{\mathit{maximum}}{\alpha}{\funtype{k}{\N{\alpha}}{\Funtype{\beta}{\arr*{\N{\beta}}{\App{\app{\App{\const{Nary}}{\alpha}}{k}}{\beta}}}}}{\\
&\quad \fun{k}{\N{\alpha}}{\Fun{\beta}{\fun{n}{\N{\beta}}{\match{k}{\fun*{x}{\App{\app{\App{\const{Nary}}{\alpha}}{x}}{\beta}}}{\\
&\qquad \App{\zero*}{\gamma} \Rightarrow n \\
&\qquad \app{\App{\succ*}{\gamma}}{k'} \Rightarrow \fun{m}{\N{\beta}}{\app{\App{\app{\App{\const{maximum}}{\gamma}}{k'}}{\beta}}{(\app{\App{\const{max}}{\beta}}{n}{m})}}}}}}}}
\end{align*}

% TODO: example with higher rank sizes
% TODO: "example" using variable substitution
% TODO: Abel's n == n + zero example?
% TODO: one other example using ==