\chapter{Syntactic Model of \lang}

\input{figures/cic.tex}

The type theory in which \lang is modelled is \CICE,
as briefly described in \cref{ch:overview}.
The key idea is that sizes in \lang can themselves be represented as a inductive type in \CICE,
and naturals and well-founded trees are then inductives with an additional size parameter.
Sizes are represented as a (generalization of) the Brouwer notation for ordinals in type theory~\citep{ordinals},
and their order as an inductive type indexed by sizes.
The order is \emph{well-founded}:
there is no infinite sequence of ever-smaller sizes,
and there is always a ``smallest'' size (or many of them).
This property allows for \emph{well-founded induction}\index{well founded!\textasciitilde~induction},
where to prove some property on sizes, one supposes that it holds for all strictly smaller sizes.

Every fixpoint expression in \lang is modelled as an instance of well-founded induction in \CICE.
To prove well-foundedness and in turn the induction principle,
I show that sizes satisfy an \emph{accessiblity predicate}\index{accessibility predicate}~\citep{accessibility}.
For the type preservation proof to go through,
\emph{definitional proof irrelevance}\index{proof irrelevance}
of accessibility predicates is required---that is,
every proof of accessibility is definitionally equal to one another.
This holds in extensional type theory via equality reflection\index{equality reflection}
but not in intensional type theory,
which is why an extensional CIC is used.

The first half of this chapter provides the syntax and judgements of \CICE.
In addition to the notation used in \cref{ch:sized-dep-types},
given variables $\vec{\xT} = \xT_1 \seq \xT_n$,
terms $\vec{\eT} = \eT_1 \seq \eT_n$,
and types $\vec{\tauT} = \tauT_1 \seq \tauT_n$,
\new{$\annotT{\vec{\xT}}{\vec{\tauT}}$} denotes the assumption environment
$\annotT*{\xT_1}{\tauT_1}, \seq, \annotT*{\xT_n}{\tauT_n}$,
\new{$\subst{\eT}{\vec{\xT}}{\vec{\eT}}$} denotes the simultaneous substitution
$\subst{\eT}{\xT_1, \seq, \xT_n}{\eT_1, \seq, \eT_n}$, 
\new{$\funT{\vec{\xT}}{\vec{\tauT}}{\eT}$} denotes the $n$-ary function
$\funT{\xT_1}{\tauT_1}{\seq \funT{\xT_n}{\tauT_n}{\eT}}$, and
\new{$\type{\GammaT}{\vec{\eT}}{\vec{\tauT}}$} denotes the $n$ typing judgements
$(\type{\GammaT}{\eT_1}{\tauT_1})$, \seq, $(\type{\GammaT, \annotT{\eT_1}{\tauT_1}, \seq, \annotT{\eT_{n-1}}{\tauT_{n-1}}}{\eT_n}{\tauT_n})$.

The second half then describes the translation from \lang to \CICE,
which is a metafunction from typing derivations of \lang to terms of \CICE.
Therefore, the translation is only defined for well-typed \lang terms,
but the type preservation theorem only applies to well-typed terms anyway.

\section{Target Type Theory}

\FigSyntaxCIC{fig:syntax-cic}
The syntax of \CICE is given in \cref{fig:syntax-cic};
differences from \lang include a 1-based index for the recursive argument of fixpoint expressions,
$\tg{case}$ expression motives abstracted over the target's inductive type indices,
and a \emph{propositional equality}\index{propositional equality} type with the reflexivity constructor and $\JT*$ eliminator.
New inductive types are defined using data definitions $\DT$,
whose syntax resembles the informal presentation used in \cref{ch:sized-dep-types}.
Metavariable usage convention is roughly the same as for \lang,
with the addition of $\pT$ for inductive type parameters or proofs of equality
and $\aT$ for inductive type indices.

The well-formedness conditions on inductive data definitions,
such as well-typedness and \emph{strict positivity}\index{strict positivity},
are entirely standard, so I don't detail them here;
see pCuIC~\citep{pCuIC} for instance for a full description.
Inductive definitions in their full generality are not needed,
and nonmutual, nonnested inductives suffice.
Indeed, only five inductive definitions are used for the translation,
for representing sizes, their order, their well-foundedness,
and naturals and well-founded trees.

The typed equivalence, subtyping, and typing judgements are defined mutually:
equivalence depends on typing and subtyping,
subtyping depends on equivalence,
and typing depends on subtyping and equivalence.
The mutual dependence is due to typed equivalence,
since with untyped conversion as seen in \lang has no typing premises.
I present first the equivalence rules in \cref{fig:equivalence},
with the subtyping and typing rules to follow.

Equivalence is, by definition, an equivalence relation,
satisfying reflexivity, symmetry, and transitivity,
and also congruent, using the same summary of congruence rules as for \lang via \rref{equiv-cong}.
An equivalence judgement can also be converted to one annotated by a supertype via \rref{equiv-conv}.
The key rule for extensionality is equality reflection\index{equality reflection} in \rref{equiv-reflect},
which definitionally equates two terms whenever there exists some proof of their propositional equality.

\FigEquiv{fig:equivalence}

\clearpage
Typed equivalence is required in the presence of equality reflection since
inconsistencies are derivable when using untyped conversion.
For instance, supposing that \lang had equality reflection and using \new{$\approx$} to denote conversion,
in the empty context, freely using transivity,
%
\begin{align*}
  \const{0'} &\approx \app{(\fun{p}{\eq{\const{0}}{\N{\hat{\hat{\circ}}}}{\const{1}}}{\const{0'}})}{\refl{\const{0'}}} &&\textrm{by $\beta$-reduction} \\
  &\approx \app{(\fun{p}{\eq{\const{0}}{\N{\hat{\hat{\circ}}}}{\const{1}}}{\const{1}})}{\refl{\const{0'}}} &&\textrm{by congruence and reflection of $p$} \\
  &\approx \const{1} &&\textrm{by $\beta$-reduction},
\end{align*}
since reduction and therefore conversion occurs even when its terms are ill-typed,
as the second and third terms are.
An alternate solution would be to disallow transitivity of conversion~\citep{CCE},
but this is too limiting when trying to prove type preservation,
and equivalence would no longer be an equivalence relation.

The remaining equivalence rules are typed versions of the usual reduction rules,
with typing premises to ensure well-typedness of both sides.
Functions have both a $\beta$-equivalence rule and an $\eta$-equivalence rule,
the latter of which is only possible since equivalence is typed.
Equivalence rules for $\tg{let}$ expressions are exactly the same as in \lang.
The $\JT*$ eliminator and $\tg{case}$ expressions reduce when applied to
equality and inductive constructors, respectively.

\rref{equiv-mu} for fixpoint expressions is \emph{unguarded}\index{guarded reduction},
meaning that fixpoints are equivalent to the substitution of itself into its own body
regardless of what they are applied to.
To maintain normalization,
the usual guarded reduction rule in intensional CIC reduces fixpoints
only when applied to a literal constructor in the recursive argument position:

\begin{mathpar}
\inferrule[\rlabel{$\equiv$-$\mu$-guarded}{equiv-mu-guarded}]{\cdots \\ \card{\vec{\eT}'} + 1 = \nT}{
  \defeq{\GammaT}{\app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\eT}'}{(\app{\cT}{\vec{\aT}})}}{\app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\eT}'}{(\app{\cT}{\vec{\aT}})}}{\tauT}
}
\end{mathpar}

Evidently \rref{equiv-mu-guarded} can be derived from \rref{equiv-mu} by congruence.
On the other hand, for any particular inductive type $\XT$,
letting $\tauT$ be $\arr{\vec{\xT}}{\vec{\sigmaT}}{\funtypeT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\tauT'}}$,
\rref{equiv-mu} can be derived from \rref{equiv-mu-guarded} via reflection of the following provable propositional equality,
freely using transitivity:

\begin{align*}
\fixT{\nT}{\fT}{\tauT}{\eT} &\eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\xT}}{\xT}}}
\qquad \textrm{definitionally by \rref{equiv-eta}} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\matchT*{\xT}{\seq(\app{\cT}{\vec{\zT}} \RightarrowT \app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\xT}}{(\app{\cT}{\vec{\pT}}{\vec{\zT}})})\seq}}} \\
& \phantom{\eq{}{}{}} \textrm{by congruence and case analysis on $\xT$} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\matchT*{\xT}{\seq(\app{\cT}{\vec{\zT}} \RightarrowT \app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\xT}}{(\app{\cT}{\vec{\pT}}{\vec{\zT}})})\seq}}} \\
& \phantom{\eq{}{}{}} \textrm{definitionally by \rref{equiv-cong, equiv-mu-guarded}} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\xT}}{\xT}}} \\
& \phantom{\eq{}{}{}} \textrm{by congruence and case analysis on $\xT$} \\
& \eq{}{}{} \subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}}
\qquad \textrm{definitionally by \rref{equiv-eta}}
\end{align*}

Since \rref{equiv-mu} and \rref{equiv-mu-guarded} are metatheoretically equivalent,
I choose to use \rref{equiv-mu} for its simplicity.

\FigSubtypingCIC{fig:subtyping-cic}
As opposed to \lang, for \CICE I use pCuIC's presentation of subtyping,
which has a typed equivalence premise in \rref{subtype-conv}.
It also has an explicit rule for transitivity of subtyping since judgements such as
$\subtype{\mt}{\app{(\funT{P}{\TypeT{\tg{1}}}{P})}{\PropT}}{\TypeT{\tg{0}}}$ would fail to hold otherwise.
Like \rref{acum-pi}, \rref{subtype-pi} is invariant in the domain of function types.

\FigTypingCIC{fig:typing-cic}