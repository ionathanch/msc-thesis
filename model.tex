\chapter{Syntactic Model of \lang}

\input{figures/cic.tex}

The type theory in which \lang is modelled is \CICE,
as briefly described in \cref{ch:overview}.
The key idea is that sizes in \lang can themselves be represented as a inductive type in \CICE,
and naturals and well-founded trees are then inductives with an additional size parameter.
Sizes are represented as a (generalization of) the Brouwer notation for ordinals in type theory~\citep{ordinals},
and their order as an inductive type indexed by sizes.
The order is \emph{well-founded}:
there is no infinite sequence of ever-smaller sizes,
and there is always a ``smallest'' size (or many of them).
This property allows for \emph{well-founded induction}\index{well founded!\textasciitilde~induction},
where to prove some property on sizes, one supposes that it holds for all strictly smaller sizes.

Every fixpoint expression in \lang is modelled as an instance of well-founded induction in \CICE.
To prove well-foundedness and in turn the induction principle,
I show that sizes satisfy an \emph{accessiblity predicate}\index{accessibility predicate}~\citep{accessibility}.
For the type preservation proof to go through,
\emph{definitional proof irrelevance}\index{proof irrelevance}
of accessibility predicates is required---that is,
every proof of accessibility is definitionally equal to one another.
This holds in extensional type theory via equality reflection\index{equality reflection}
but not in intensional type theory,
which is why an extensional CIC is used.

The first half of this chapter provides the syntax and judgements of \CICE.
In addition to the notation used in \cref{ch:sized-dep-types},
given variables $\vec{\xT} = \xT_1 \seq \xT_n$,
terms $\vec{\eT} = \eT_1 \seq \eT_n$,
and types $\vec{\tauT} = \tauT_1 \seq \tauT_n$,
\new{$\annotT{\vec{\xT}}{\vec{\tauT}}$} denotes the assumption environment
$\annotT*{\xT_1}{\tauT_1}, \seq, \annotT*{\xT_n}{\tauT_n}$,
\new{$\subst{\eT}{\vec{\xT}}{\vec{\eT}}$} denotes the simultaneous substitution
$\subst{\eT}{\xT_1, \seq, \xT_n}{\eT_1, \seq, \eT_n}$, 
\new{$\funT{\vec{\xT}}{\vec{\tauT}}{\eT}$} denotes the $n$-ary function
$\funT{\xT_1}{\tauT_1}{\seq \funT{\xT_n}{\tauT_n}{\eT}}$, and
\new{$\type{\GammaT}{\vec{\eT}}{\vec{\tauT}}$} denotes the $n$ typing judgements
$(\type{\GammaT}{\eT_1}{\tauT_1})$, \seq, $(\type{\GammaT, \annotT{\eT_1}{\tauT_1}, \seq, \annotT{\eT_{n-1}}{\tauT_{n-1}}}{\eT_n}{\tauT_n})$.

The second half then describes the translation from \lang to \CICE,
which is a metafunction from typing derivations of \lang to terms of \CICE.
Therefore, the translation is only defined for well-typed \lang terms,
but the type preservation theorem only applies to well-typed terms anyway.

\section{Target Type Theory}

\FigSyntaxCIC{fig:syntax-cic}
The syntax of \CICE is given in \cref{fig:syntax-cic};
differences from \lang include a 1-based index for the recursive argument of fixpoint expressions,
$\tg{case}$ expression motives abstracted over the target's inductive type indices,
and a \emph{propositional equality}\index{propositional equality} type with the reflexivity constructor and $\JT*$ eliminator.
New inductive types are defined using data definitions $\DT$,
whose syntax resembles the informal presentation used in \cref{ch:sized-dep-types}.
Metavariable usage convention is roughly the same as for \lang,
with the addition of $\pT$ for inductive type parameters or proofs of equality
and $\aT$ for inductive type indices.

The well-formedness conditions on inductive data definitions,
such as well-typedness and \emph{strict positivity}\index{strict positivity},
are entirely standard, so I don't detail them here;
see pCuIC~\citep{pCuIC} for instance for a full description.
Inductive definitions in their full generality are not needed,
and nonmutual, nonnested inductives suffice.
Indeed, only five inductive definitions are used for the translation,
for representing sizes, their order, their well-foundedness,
and naturals and well-founded trees.

The typed equivalence, subtyping, and typing judgements are defined mutually:
equivalence depends on typing and subtyping,
subtyping depends on equivalence,
and typing depends on subtyping and equivalence.
The mutual dependence is due to typed equivalence,
since with untyped conversion as seen in \lang has no typing premises.
I present first the equivalence rules in \cref{fig:equivalence},
with the subtyping and typing rules to follow.

Equivalence is, by definition, an equivalence relation,
satisfying reflexivity, symmetry, and transitivity,
and also congruent, using the same summary of congruence rules as for \lang via \rref{equiv-cong}.
An equivalence judgement can also be converted to one annotated by a supertype via \rref{equiv-conv}.
The key rule for extensionality is equality reflection\index{equality reflection} in \rref{equiv-reflect},
which definitionally equates two terms whenever there exists some proof of their propositional equality.

\FigEquiv{fig:equivalence}

\clearpage
Typed equivalence is required in the presence of equality reflection since
inconsistencies are derivable when using untyped conversion.
For instance, supposing that \lang had equality reflection and using \new{$\approx$} to denote conversion,
in the empty context, freely using transivity,
%
\begin{align*}
  \const{0'} &\approx \app{(\fun{p}{\eq{\const{0}}{\N{\hat{\hat{\circ}}}}{\const{1}}}{\const{0'}})}{\refl{\const{0'}}} &&\textrm{by $\beta$-reduction} \\
  &\approx \app{(\fun{p}{\eq{\const{0}}{\N{\hat{\hat{\circ}}}}{\const{1}}}{\const{1}})}{\refl{\const{0'}}} &&\textrm{by congruence and reflection of $p$} \\
  &\approx \const{1} &&\textrm{by $\beta$-reduction},
\end{align*}
since reduction and therefore conversion occurs even when its terms are ill-typed,
as the second and third terms are.
An alternate solution would be to disallow transitivity of conversion~\citep{CCE},
but this is too limiting when trying to prove type preservation,
and equivalence would no longer be an equivalence relation.

The remaining equivalence rules are typed versions of the usual reduction rules,
with typing premises to ensure well-typedness of both sides.
Functions have both a $\beta$-equivalence rule and an $\eta$-equivalence rule,
the latter of which is only possible since equivalence is typed.
Equivalence rules for $\tg{let}$ expressions are exactly the same as in \lang.
The $\JT*$ eliminator and $\tg{case}$ expressions reduce when applied to
equality and inductive constructors, respectively.

\rref{equiv-mu} for fixpoint expressions is \emph{unguarded}\index{guarded reduction},
meaning that fixpoints are equivalent to the substitution of itself into its own body
regardless of what they are applied to.
To maintain normalization,
the usual guarded reduction rule in intensional CIC reduces fixpoints
only when applied to a literal constructor in the recursive argument position:

\begin{mathpar}
\inferrule[\rlabel{$\equiv$-$\mu$-guarded}{equiv-mu-guarded}]{\cdots \\ \card{\vec{\eT}'} + 1 = \nT}{
  \defeq{\GammaT}{\app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\eT}'}{(\app{\cT}{\vec{\aT}})}}{\app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\eT}'}{(\app{\cT}{\vec{\aT}})}}{\tauT}
}
\end{mathpar}

Evidently \rref{equiv-mu-guarded} can be derived from \rref{equiv-mu} by congruence.
On the other hand, for any particular inductive type $\XT$,
letting $\tauT$ be $\arr{\vec{\xT}}{\vec{\sigmaT}}{\funtypeT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\tauT'}}$,
\rref{equiv-mu} can be derived from \rref{equiv-mu-guarded} via reflection of the following provable propositional equality,
freely using transitivity:

\begin{align*}
\fixT{\nT}{\fT}{\tauT}{\eT} &\eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\xT}}{\xT}}}
\qquad \textrm{definitionally by \rref{equiv-eta}} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\matchT*{\xT}{\seq(\app{\cT}{\vec{\zT}} \RightarrowT \app{(\fixT{\nT}{\fT}{\tauT}{\eT})}{\vec{\xT}}{(\app{\cT}{\vec{\pT}}{\vec{\zT}})})\seq}}} \\
& \phantom{\eq{}{}{}} \textrm{by congruence and case analysis on $\xT$} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\matchT*{\xT}{\seq(\app{\cT}{\vec{\zT}} \RightarrowT \app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\xT}}{(\app{\cT}{\vec{\pT}}{\vec{\zT}})})\seq}}} \\
& \phantom{\eq{}{}{}} \textrm{definitionally by \rref{equiv-cong, equiv-mu-guarded}} \\
& \eq{}{}{} \funT{\vec{\xT}}{\vec{\sigmaT}}{\funT{\xT}{\app{\XT}{\vec{\pT}}{\vec{\aT}}}{\app{(\subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}})}{\vec{\xT}}{\xT}}} \\
& \phantom{\eq{}{}{}} \textrm{by congruence and case analysis on $\xT$} \\
& \eq{}{}{} \subst{\eT}{\fT}{\fixT{\nT}{\fT}{\tauT}{\eT}}
\qquad \textrm{definitionally by \rref{equiv-eta}}
\end{align*}

Since \rref{equiv-mu} and \rref{equiv-mu-guarded} are metatheoretically equivalent,
I choose to use \rref{equiv-mu} for its simplicity.

\FigSubtypingCIC{fig:subtyping-cic}
As opposed to \lang, for \CICE I use pCuIC's presentation of subtyping,
which has a typed equivalence premise in \rref{subtype-conv}.
It also has an explicit rule for transitivity of subtyping since judgements such as
$\subtype{\mt}{\app{(\funT{P}{\TypeT{\tg{1}}}{P})}{\PropT}}{\TypeT{\tg{0}}}$ would fail to hold otherwise.
Like \rref{acum-pi}, \rref{subtype-pi} is invariant in the domain of function types.

The typing and environment well-formedness rules are in \cref{fig:typing-cic}.
Except for \rref{fix*}, the starred rules are the same as for \lang,
with metafunctions $\axioms{\mt}$ and $\rules{\mt}{\mt}$ operating similarly on universes $\UT$
as in \cref{fig:rules-axioms}.
An additional premise to \rref{fix*} ensures that the $\nT$th argument is indeed an inductive type.
% in addition to checking well-typedness of fixpoint bodies with possible recursive references.

As previously mentioned, fixpoints must also be \emph{guarded}\index{guardedness}:
recursive calls can only occur on structurally smaller arguments of elements of inductives.
This \emph{guard condition} is well-studied~\citep{guard, guard-relax, Coq} and so omitted here.
To justify uses of fixpoint expressions in the translation,
I will provide either a mechanization or present a brief argument of guardedness.

\FigTypingCIC{fig:typing-cic}

The new \rref{eq, refl, J} are for the propositional equality\index{propositional equality} type,
its constructor, and its eliminator.
Given some equality proof $\pT$ of $\eqT{\eT_1}{\tauT}{\eT_2}$
and a motive\index{motive} $\PT$ dependent on a proof of equality
whose left-hand side is fixed at $\eT_1$ and right-hand side is variable%
\footnote{Occasionally referred to as \emph{Paulin-Mohring}'s equality,
as opposed to \emph{Martin-L\"of}'s equality
where the left-hand side is variable as well.},
to prove $\app{\PT}{\eT_2}{\pT}$ it suffices to provide to $\JT*$ a proof that
$\app{\PT}{\eT_1}{\refl{\eT_1}}$ holds.
Other usual functions on proofs of equality can be derived from it,
such as coercion (when the motive is a constant function on types in its first argument)
or substitution (when the motive ignores the second argument),
as well as proofs of symmetry, transitivity, and congruence of equality.
The proof of type preservation eliminates propositional equalities mostly through reflection rather than using $\JT*$,
but I retain $\JT*$ in \CICE for completeness.%
\footnote{The combined presence of $\JT*$ and equality reflection also allows proving the
\emph{uniqueness of identity proofs} (UIP)\index{uniqueness of identity proofs},
or that all proofs of an equality are themselves equal to one another.}

\rref{ind, constr, case} assign types to inductive types, their constructors,
and $\tg{case}$ expressions, under the premise that
the relevant inductive data definition exists and is well-formed.
Here, the difference between the parameters and the indices of inductive types becomes apparent:
the motive\index{motive} of a $\tg{case}$ expression is abstracted over the indices by $\vec{\yT}$
in addition to the target by $\xT$, while the parameters $\vec{\pT}$ are fixed throughout.
Therefore, when dealing with the types of indices and constructor arguments,
the parameters are first substituted in place of $\vec{\wT}$.

A $\tg{case}$ expression is well typed if its target is, if its motive is for any indices and according target,
and if each branch is well typed for that branch's constructor arguments,
where its type is the motive with the appropriate indices and reconstructed target.
For notational simplicity, the rule assumes that the binding variable names
$\vec{\yT}$ and $\vec{\zT}$ are those found in the data definition,
but of course these can be renamed at the expense of additional renaming substitutions.

The typing premises of
\rref{equiv-beta, equiv-zeta, equiv-rho, equiv-iota, equiv-mu}
corresponding to some of the reduction rules duplicate the premises found in many of the typing rules,
trivially ensuring that both sizes of these equivalences are well-typed with the same type
(a property known as \emph{subject equivalence}\index{subject reduction}).

\section{Preliminary Definitions}